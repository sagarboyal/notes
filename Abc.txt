Code for SfClient.java

package com.mahindrafinance.fos.service.sfsync;

import static com.mahindrafinance.fos.api.sfsync.response.SfSyncVo.buildBasicSfSyncVo;
import static com.mahindrafinance.fos.exceptions.MfErrorCode.*;
import static com.mahindrafinance.fos.mapper.SfSyncMapper.*;
import static com.mahindrafinance.fos.master.enums.MatchType.EXACT_MATCH;
import static com.mahindrafinance.fos.master.enums.MatchType.PARTIAL_MATCH;
import static com.mahindrafinance.fos.master.enums.SfSyncStage.*;
import static com.mahindrafinance.fos.master.enums.SfSyncStage.DDE;
import static com.mahindrafinance.fos.service.sfsync.SfSyncErrorProcessor.buildErrorResponse;
import static com.mahindrafinance.fos.service.sfsync.SfSyncErrorProcessor.parseIfResponseIsSuccessful;
import static com.mahindrafinance.fos.service.sfsync.helper.LoanRequestHelper.buildApplicationRequest;
import static com.mahindrafinance.fos.service.sfsync.helper.LoanRequestHelper.buildLoanAssetRequest;
import static com.mahindrafinance.fos.service.sfsync.helper.UrlHelper.*;
import static com.mahindrafinance.fos.util.Constants.*;
import static com.mahindrafinance.fos.util.enums.AddressType.CURRENT;
import static com.mahindrafinance.fos.util.enums.AddressType.PERMANENT;
import static com.mahindrafinance.fos.util.enums.AddressType.WORK;
import static com.mahindrafinance.fos.util.enums.SfSyncResource.*;
import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static org.apache.commons.lang3.BooleanUtils.TRUE;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mahindrafinance.fos.api.sentback.service.SentBackService;
import com.mahindrafinance.fos.api.sfsync.request.AddOnProductMappingVo;
import com.mahindrafinance.fos.api.sfsync.response.AddressMappingVo;
import com.mahindrafinance.fos.api.sfsync.response.InsuredDetailMappingVo;
import com.mahindrafinance.fos.api.sfsync.response.SfSyncResponse;
import com.mahindrafinance.fos.api.sfsync.response.SfSyncVo;
import com.mahindrafinance.fos.client.consent.ConsentClient;
import com.mahindrafinance.fos.client.consent.response.ConsentResponse;
import com.mahindrafinance.fos.client.customer.CustomerClient;
import com.mahindrafinance.fos.client.customer.response.AddressMatchStrengthResponse;
import com.mahindrafinance.fos.client.customer.response.AddressResponse;
import com.mahindrafinance.fos.client.customer.response.AmlResponse;
import com.mahindrafinance.fos.client.customer.response.CustomerResponse;
import com.mahindrafinance.fos.client.customer.response.DedupeAndExposureResponse;
import com.mahindrafinance.fos.client.document.DocResponse;
import com.mahindrafinance.fos.client.document.Document;
import com.mahindrafinance.fos.client.document.DocumentClient;
import com.mahindrafinance.fos.client.kyc.KycClient;
import com.mahindrafinance.fos.client.kyc.response.KycResponse;
import com.mahindrafinance.fos.client.kyc.response.KycVerificationDetailsResponse;
import com.mahindrafinance.fos.client.lead.LeadClient;
import com.mahindrafinance.fos.client.lead.response.LeadDetailsResponse;
import com.mahindrafinance.fos.client.loan.LoanClient;
import com.mahindrafinance.fos.client.loan.response.*;
import com.mahindrafinance.fos.client.loan.response.dde.BankingResponse;
import com.mahindrafinance.fos.client.loan.response.dde.IHMResponse;
import com.mahindrafinance.fos.client.loan.response.dde.OverDueCharge;
import com.mahindrafinance.fos.client.loan.response.dde.PostSanctionLoanResponse;
import com.mahindrafinance.fos.client.master.MasterDataClient;
import com.mahindrafinance.fos.client.master.response.AddOnProductResponse;
import com.mahindrafinance.fos.client.master.response.DisbursementBankDetailResponse;
import com.mahindrafinance.fos.client.offer.OfferClient;
import com.mahindrafinance.fos.client.offer.response.InsuranceResponse;
import com.mahindrafinance.fos.client.offer.response.OfferDetails;
import com.mahindrafinance.fos.client.offer.response.OfferResponse;
import com.mahindrafinance.fos.client.sfsync.SfClient;
import com.mahindrafinance.fos.client.sfsync.request.AddOnProduct;
import com.mahindrafinance.fos.client.sfsync.request.Address;
import com.mahindrafinance.fos.client.sfsync.request.Applicant;
import com.mahindrafinance.fos.client.sfsync.request.BankingDetail;
import com.mahindrafinance.fos.client.sfsync.request.BureauResponse;
import com.mahindrafinance.fos.client.sfsync.request.CompositeRequest;
import com.mahindrafinance.fos.client.sfsync.request.DedupeExposureRequest;
import com.mahindrafinance.fos.client.sfsync.request.DocumentChecklist;
import com.mahindrafinance.fos.client.sfsync.request.GraphRequest;
import com.mahindrafinance.fos.client.sfsync.request.Graphs;
import com.mahindrafinance.fos.client.sfsync.request.LoanApplication;
import com.mahindrafinance.fos.client.sfsync.request.LoanCharge;
import com.mahindrafinance.fos.client.sfsync.request.PostSanctionApplicant;
import com.mahindrafinance.fos.client.sfsync.request.PostSanctionLoanApplication;
import com.mahindrafinance.fos.client.sfsync.response.CompositeResponse;
import com.mahindrafinance.fos.client.sfsync.response.Graph;
import com.mahindrafinance.fos.client.sfsync.response.GraphResponse;
import com.mahindrafinance.fos.client.sfsync.response.GraphResponseDetail;
import com.mahindrafinance.fos.client.sfsync.response.SuccessBody;
import com.mahindrafinance.fos.client.user.UserServiceClient;
import com.mahindrafinance.fos.client.user.response.UserDetails;
import com.mahindrafinance.fos.commons.api.response.MfResponse;
import com.mahindrafinance.fos.commons.enums.ApplicationState;
import com.mahindrafinance.fos.commons.exceptions.EntityNotFoundException;
import com.mahindrafinance.fos.commons.exceptions.ExternalServiceResponseException;
import com.mahindrafinance.fos.commons.exceptions.InvalidRequestException;
import com.mahindrafinance.fos.master.enums.SfSyncStage;
import com.mahindrafinance.fos.repository.*;
import com.mahindrafinance.fos.repository.entity.AddOnProductMapping;
import com.mahindrafinance.fos.repository.entity.AddressMapping;
import com.mahindrafinance.fos.repository.entity.ApplicantMapping;
import com.mahindrafinance.fos.repository.entity.ApplicationMapping;
import com.mahindrafinance.fos.repository.entity.BankDetailsMapping;
import com.mahindrafinance.fos.repository.entity.BureauResponseMapping;
import com.mahindrafinance.fos.repository.entity.ChargeMapping;
import com.mahindrafinance.fos.repository.entity.ChecklistIdMapping;
import com.mahindrafinance.fos.repository.entity.DocReferenceIdMapping;
import com.mahindrafinance.fos.repository.entity.LoanAssetMapping;
import com.mahindrafinance.fos.repository.entity.PayoutDetailsMapping;
import com.mahindrafinance.fos.service.casehistory.CaseHistoryService;
import com.mahindrafinance.fos.service.sfsync.handlers.ApplicantFinancialsRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.CPVRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.ConditionAndDeviationRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.IncomeAssessmentRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.PayoutRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.RepaymentRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.WithdrawalRequestHandler;
import com.mahindrafinance.fos.util.enums.AddressType;
import com.mahindrafinance.fos.util.enums.CustomerType;
import com.mahindrafinance.fos.util.enums.OfferType;
import com.mahindrafinance.fos.util.enums.SfSyncResource;
import com.mahindrafinance.fos.util.enums.UnderwriterApprovalType;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

@Service
@Slf4j
public class SfService {
    private final LoanClient loanClient;
    private final KycClient kycClient;
    private final CustomerClient customerClient;
    private final LeadClient leadClient;
    private final ConsentClient consentClient;
    private final SfClient sfClient;
    private final MasterDataClient masterDataClient;
    private final UserServiceClient userServiceClient;
    private final OfferClient offerClient;
    private final DocumentClient documentClient;
    private final SfDocSyncService sfDocSyncService;
    private final SfPreDoDocSyncService sfPreDoDocSyncService;
    private final SfPreDoCpcSyncService sfPreDoCpcSyncService;
    private final SentBackService sentBackService;
    private final UnderwriterApprovalService underwriterApprovalService;
    private final InsuredDetailService insuredDetailHelper;
    private final RepaymentRequestHandler repaymentRequestHandler;
    private final ObjectMapper objectMapper;
    private final ApplicationMappingRepository applicationMappingRepository;
    private final AddOnProductMappingRepository addOnProductMappingRepository;
    private final ApplicantMappingRepository applicantMappingRepository;
    private final DocReferenceIdMappingRepository docReferenceIdMappingRepository;
    private final ChecklistIdMappingRepository checklistIdMappingRepository;
    private final LoanAssetMappingRepository loanAssetMappingRepository;
    private final ChargeMappingRepository chargeMappingRepository;
    private final IncomeAssessmentRequestHandler incomeAssessmentRequestHandler;
    private final SfBreOutputSyncService sfBreOutputSyncService;
    private final BankDetailsMappingRepository bankDetailsMappingRepository;
    private final CaseHistoryService caseHistoryService;
    private final CPVRequestHandler cpvRequestHandler;
    private final ConditionAndDeviationRequestHandler conditionAndDeviationRequestHandler;
    private final AddressMappingRepository addressMappingRepository;
    private final BureauResponseMappingRepository bureauResponseMappingRepository;

    private final WithdrawalRequestHandler withdrawalRequestHandler;
    private final LoanSanctionDateRequestHandler loanSanctionDateRequestHandler;

    private final ApplicantFinancialsRequestHandler applicantFinancialsRequestHandler;
    private final PayoutRequestHandler payoutRequestHandler;
    private final PayoutDetailsMappingRepository payoutDetailsMappingRepository;

    @Value("${external-service.sf.api-version}")
    private String sfApiVersion;

    @Value("${internal-config.env:default}")
    private String envVariable;

    @Autowired
    public SfService(
            LoanClient loanClient,
            LeadClient leadClient,
            KycClient kycClient,
            CustomerClient customerClient,
            ConsentClient consentClient,
            SfClient sfClient,
            DocumentClient documentClient,
            SfDocSyncService sfDocSyncService,
            SfPreDoDocSyncService sfPreDoDocSyncService,
            UnderwriterApprovalService underwriterApprovalService,
            ObjectMapper objectMapper,
            MasterDataClient masterDataClient,
            UserServiceClient userServiceClient,
            OfferClient offerClient,
            SfPreDoCpcSyncService sfPreDoCpcSyncService,
            SentBackService sentBackService,
            InsuredDetailService insuredDetailHelper,
            ApplicationMappingRepository applicationMappingRepository,
            AddOnProductMappingRepository addOnProductMappingRepository,
            ApplicantMappingRepository applicantMappingRepository,
            DocReferenceIdMappingRepository docReferenceIdMappingRepository,
            ChecklistIdMappingRepository checklistIdMappingRepository,
            RepaymentRequestHandler repaymentRequestHandler,
            LoanAssetMappingRepository loanAssetMappingRepository,
            ChargeMappingRepository chargeMappingRepository,
            BankDetailsMappingRepository bankDetailsMappingRepository,
            IncomeAssessmentRequestHandler incomeAssessmentRequestHandler,
            SfBreOutputSyncService sfBreOutputSyncService,
            CaseHistoryService caseHistoryService,
            CPVRequestHandler cpvRequestHandler,
            ConditionAndDeviationRequestHandler conditionAndDeviationRequestHandler,
            AddressMappingRepository addressMappingRepository,
            BureauResponseMappingRepository bureauResponseMappingRepository,
            WithdrawalRequestHandler withdrawalRequestHandler,
            LoanSanctionDateRequestHandler loanSanctionDateRequestHandler,
            ApplicantFinancialsRequestHandler applicantFinancialsRequestHandler,
            PayoutRequestHandler payoutRequestHandler,
            PayoutDetailsMappingRepository payoutDetailsMappingRepository) {
        this.loanClient = loanClient;
        this.leadClient = leadClient;
        this.kycClient = kycClient;
        this.customerClient = customerClient;
        this.consentClient = consentClient;
        this.sfClient = sfClient;
        this.documentClient = documentClient;
        this.sfDocSyncService = sfDocSyncService;
        this.sfPreDoDocSyncService = sfPreDoDocSyncService;
        this.underwriterApprovalService = underwriterApprovalService;
        this.masterDataClient = masterDataClient;
        this.objectMapper = objectMapper;
        this.userServiceClient = userServiceClient;
        this.offerClient = offerClient;
        this.sfPreDoCpcSyncService = sfPreDoCpcSyncService;
        this.sentBackService = sentBackService;
        this.insuredDetailHelper = insuredDetailHelper;
        this.applicationMappingRepository = applicationMappingRepository;
        this.applicantMappingRepository = applicantMappingRepository;
        this.addOnProductMappingRepository = addOnProductMappingRepository;
        this.docReferenceIdMappingRepository = docReferenceIdMappingRepository;
        this.checklistIdMappingRepository = checklistIdMappingRepository;
        this.repaymentRequestHandler = repaymentRequestHandler;
        this.loanAssetMappingRepository = loanAssetMappingRepository;
        this.chargeMappingRepository = chargeMappingRepository;
        this.incomeAssessmentRequestHandler = incomeAssessmentRequestHandler;
        this.sfBreOutputSyncService = sfBreOutputSyncService;
        this.bankDetailsMappingRepository = bankDetailsMappingRepository;
        this.caseHistoryService = caseHistoryService;
        this.cpvRequestHandler = cpvRequestHandler;
        this.conditionAndDeviationRequestHandler = conditionAndDeviationRequestHandler;
        this.addressMappingRepository = addressMappingRepository;
        this.bureauResponseMappingRepository = bureauResponseMappingRepository;
        this.withdrawalRequestHandler = withdrawalRequestHandler;
        this.loanSanctionDateRequestHandler = loanSanctionDateRequestHandler;
        this.applicantFinancialsRequestHandler = applicantFinancialsRequestHandler;
        this.payoutRequestHandler = payoutRequestHandler;
        this.payoutDetailsMappingRepository = payoutDetailsMappingRepository;
    }

    public SfSyncResponse syncDataToSf(String applicationId, SfSyncStage sfSyncStage) throws JsonProcessingException {
        switch (sfSyncStage) {
            case UPTO_QDE1 -> {
                syncQde1DataToSf(applicationId);
                return deactivatePreviousQde(applicationId);
            }
            case DDE -> {
                return syncCoAppAndGuarantorPostSanctionDataToSf(applicationId);
            }
            case DOC_UPLOAD -> {
                return sfDocSyncService.syncDocUploadDataToSf(applicationId, getApplicationState(applicationId));
            }
            case ADD_ON_PRODUCTS -> {
                return syncAddOnProducts(applicationId);
            }
            case REPAYMENT_SCHEDULE -> {
                return repaymentRequestHandler.syncJob(applicationId);
            }
            case CPV -> {
                return cpvRequestHandler.syncJob(applicationId);
            }
            case INCOME_ASSESSMENT -> {
                applicantFinancialsRequestHandler.syncJob(applicationId);
                return incomeAssessmentRequestHandler.syncJob(applicationId);
            }
            case INCOME_VALIDATION -> {
                return applicantFinancialsRequestHandler.syncJob(applicationId);
            }
            case BRE_OUTPUT -> {
                return sfBreOutputSyncService.syncBreOutput(applicationId);
            }
            case UW_APPROVAL -> {
                sfBreOutputSyncService.syncBreOutput(applicationId);
                syncAddOnProducts(applicationId);
                repaymentRequestHandler.syncJob(applicationId);
                conditionAndDeviationRequestHandler.syncJob(applicationId);
                underwriterApprovalService.send(applicationId, UnderwriterApprovalType.SANCTION);
                return sfDocSyncService.syncDocUploadDataToSf(applicationId, getApplicationState(applicationId));
            }
            case CONDITION_AND_DEVIATION -> {
                return conditionAndDeviationRequestHandler.syncJob(applicationId);
            }
            case SANCTION -> {
                sfBreOutputSyncService.syncBreOutput(applicationId);
                syncAddOnProducts(applicationId);
                repaymentRequestHandler.syncJob(applicationId);
                return conditionAndDeviationRequestHandler.syncJob(applicationId);
            }
            case WITHDRAWAL -> {
                return withdrawalRequestHandler.syncJob(applicationId);
            }
            case LOAN_SANCTION_DATE -> {
                return loanSanctionDateRequestHandler.syncJob(applicationId);
            }
            default -> throw new InvalidRequestException(INVALID_STAGE);
        }
    }

    public SfSyncResponse syncDataToSf(String applicationId, SfSyncStage sfSyncStage, String customerId) {
        if (CPV.equals(sfSyncStage)) {
            return cpvRequestHandler.syncJob(applicationId, customerId);
        } else {
            throw new InvalidRequestException(INVALID_STAGE);
        }
    }

    private SfSyncResponse deactivatePreviousQde(String applicationId) {
        List<CompositeRequest> compositeRequest = new ArrayList<>();
        addQdeTwoQdeThreeInactiveCompositeRequests(applicationId, compositeRequest);
        if (compositeRequest.isEmpty()) {
            return SfSyncResponse.builder()
                    .isSuccessful(Boolean.TRUE.toString())
                    .build();
        }

        Graphs graph =
                Graphs.builder().graphId("1").compositeRequest(compositeRequest).build();
        GraphRequest graphRequest =
                GraphRequest.builder().graphs(Collections.singletonList(graph)).build();

        logPayload("Deactivate Previous QDE", applicationId, graphRequest);
        GraphResponseDetail sfResponse = sfClient.postToSf(graphRequest);

        SfSyncVo sfSyncVo = SfSyncVo.builder()
                .applicationId(applicationId)
                .isQdeDeactivation(Boolean.TRUE)
                .build();
        SfSyncResponse sfSyncResponse = parseSfResponse(sfResponse.getGraphs().getFirst(), sfSyncVo, UPTO_QDE1);
        return parseIfResponseIsSuccessful(sfSyncResponse);
    }

    public SfSyncResponse getSynchronousSfSyncResponse(String applicationId, SfSyncStage stage)
            throws JsonProcessingException {
        switch (stage) {
            case UW_APPROVAL -> {
                sfBreOutputSyncService.syncBreOutput(applicationId);
                repaymentRequestHandler.syncJob(applicationId);
                syncAddOnProducts(applicationId);
                conditionAndDeviationRequestHandler.syncJob(applicationId);
                SfSyncResponse sfSyncResponse =
                        underwriterApprovalService.send(applicationId, UnderwriterApprovalType.SANCTION);
                sfDocSyncService.syncDocUploadDataToSf(applicationId, getApplicationState(applicationId));
                caseHistoryService.saveUWSentBackForSubmittedApplication(applicationId);
                return sfSyncResponse;
            }
            case UW_APPROVAL_DEFERRAL_NO_DEVIATION -> {
                sfBreOutputSyncService.syncBreOutput(applicationId);
                repaymentRequestHandler.syncJob(applicationId);
                syncAddOnProducts(applicationId);
                SfSyncResponse sfSyncResponse =
                        underwriterApprovalService.send(applicationId, UnderwriterApprovalType.SANCTION);
                sfDocSyncService.syncDocUploadDataToSf(applicationId, getApplicationState(applicationId));
                caseHistoryService.saveUWSentBackForSubmittedApplication(applicationId);
                return sfSyncResponse;
            }
            case DOC_UPLOAD -> {
                ApplicationState applicationStatus = getApplicationState(applicationId);
                SfSyncResponse sfSyncResponse =
                        sfDocSyncService.syncDocUploadDataToSf(applicationId, applicationStatus);
                sentBackService.updateStatusAsCompletedForSubmittedApplication(applicationId);
                saveCaseHistoryForDDECPCSubmission(applicationId, applicationStatus);
                return sfSyncResponse;
            }
            case PRE_DO_CPC_VALIDATION -> {
                SfSyncResponse sfSyncResponse = sfPreDoCpcSyncService.sync(applicationId);
                sentBackService.updateStatusAsCompletedForSubmittedApplicationForTvrAndPreDo(applicationId);
                caseHistoryService.saveCPCSentBackForSubmittedApplication(applicationId);
                return sfSyncResponse;
            }
            case PRE_DO_DOC_UPLOAD -> {
                return sfPreDoDocSyncService.sync(applicationId);
            }
            case LOAN_SANCTION_DATE -> {
                return loanSanctionDateRequestHandler.syncJob(applicationId);
            }
            case REPAYMENT_SCHEDULE -> {
                return repaymentRequestHandler.syncJob(applicationId);
            }
            default -> throw new InvalidRequestException(INVALID_STAGE);
        }
    }

    public SfSyncResponse getSynchronousSfSyncResponse(String applicationId, SfSyncStage stage, String customerId)
            throws JsonProcessingException {
        switch (stage) {
            case UW_APPROVAL -> {
                MfResponse<LoanDetailsResponse> loanDetailsResponse = loanClient.fetchLoanDetails(applicationId);
                UUID primaryApplicant =
                        getPrimaryCustomer(loanDetailsResponse.getData()).getCustomerId();
                sfBreOutputSyncService.syncCoAppAndGuarantorBreOutput(applicationId, primaryApplicant);
                syncCoAppAndGuarantorAddOnProducts(applicationId, primaryApplicant);
                repaymentRequestHandler.syncJob(applicationId);

                conditionAndDeviationRequestHandler.syncJob(applicationId);

                SfSyncResponse sfSyncResponse =
                        underwriterApprovalService.send(applicationId, UnderwriterApprovalType.SANCTION);
                sfDocSyncService.syncCoAppAndGuarantorDocUploadDataToSf(
                        applicationId, getApplicationState(applicationId), primaryApplicant);
                caseHistoryService.saveUWSentBackForSubmittedApplication(applicationId);
                return sfSyncResponse;
            }
            case DOC_UPLOAD -> {
                ApplicationState applicationStatus = getApplicationState(applicationId);
                SfSyncResponse sfSyncResponse =
                        sfDocSyncService.syncDocUploadDataToSf(applicationId, applicationStatus, customerId);
                sentBackService.updateStatusAsCompletedForSubmittedApplication(applicationId);
                saveCaseHistoryForDDECPCSubmission(applicationId, applicationStatus);
                return sfSyncResponse;
            }
            case PRE_DO_CPC_VALIDATION -> {
                SfSyncResponse sfSyncResponse = sfPreDoCpcSyncService.sync(applicationId, customerId);
                sentBackService.updateStatusAsCompletedForSubmittedApplicationForTvrAndPreDo(applicationId);
                caseHistoryService.saveCPCSentBackForSubmittedApplication(applicationId);
                return sfSyncResponse;
            }
            case PRE_DO_DOC_UPLOAD -> {
                return sfPreDoDocSyncService.sync(applicationId, customerId);
            }
            case LOAN_SANCTION_DATE -> {
                return loanSanctionDateRequestHandler.syncJob(applicationId);
            }
            case REPAYMENT_SCHEDULE -> {
                return repaymentRequestHandler.syncJob(applicationId);
            }
            default -> throw new InvalidRequestException(INVALID_STAGE);
        }
    }

    private SfSyncResponse syncCoAppAndGuarantorAddOnProducts(String applicationId, UUID primaryApplicant) {
        log.info(
                "SalesForce data sync for Add On Product stage has been started for the Application Id: {}.",
                applicationId);
        ApplicantMapping applicantMapping =
                getApplicantMappingByApplicationIdAndApplicantId(applicationId, primaryApplicant);

        OfferResponse offers =
                offerClient.getOffers(applicationId, Boolean.TRUE).getData();
        OfferDetails selectedOffer = offers.getOfferList().getFirst();
        UUID offerId = selectedOffer.getOfferId();
        MfResponse<InsuranceResponse> insuranceMfResponse = offerClient.getInsuranceDetails(offerId);
        InsuranceResponse insuranceData = insuranceMfResponse.getData();

        GraphRequest graphRequest = isInsuranceDataPresent(insuranceData)
                ? createGraphRequestForAddOnProducts(
                        applicationId, insuranceData, applicantMapping.getSfApplicantId(), offerId)
                : createRequestForInactiveInsuranceDetails(applicationId, offerId);

        logPayload(ADD_ON_PRODUCTS.getValue(), applicationId, graphRequest);

        if (CollectionUtils.isEmpty(graphRequest.getGraphs().getFirst().getCompositeRequest())) {
            log.info("[syncAddOnProducts] Add on products not found for for application id {} ", applicationId);
            return SfSyncResponse.builder().isSuccessful("true").build();
        }
        GraphResponseDetail sfResponse = sfClient.postToSf(graphRequest);

        SfSyncVo sfSyncVo = SfSyncVo.builder()
                .applicationId(applicationId)
                .offerId(selectedOffer.getOfferId())
                .applicationMapping(applicantMapping.getApplicationMapping())
                .build();

        insuredDetailHelper.setInsuredDetailMappingsMap(sfSyncVo, insuranceData);

        SfSyncResponse sfSyncResponse = parseSfResponse(sfResponse.getGraphs().getFirst(), sfSyncVo, ADD_ON_PRODUCTS);
        return parseIfResponseIsSuccessful(sfSyncResponse);
    }

    private SfSyncResponse syncAddOnProducts(String applicationId) {
        log.info(
                "SalesForce data sync for Add On Product stage has been started for the Application Id: {}.",
                applicationId);
        ApplicantMapping applicantMapping = getApplicantMappingByApplicationId(applicationId);

        OfferResponse offers =
                offerClient.getOffers(applicationId, Boolean.TRUE).getData();
        OfferDetails selectedOffer = offers.getOfferList().getFirst();
        UUID offerId = selectedOffer.getOfferId();
        MfResponse<InsuranceResponse> insuranceMfResponse = offerClient.getInsuranceDetails(offerId);
        InsuranceResponse insuranceData = insuranceMfResponse.getData();

        GraphRequest graphRequest = isInsuranceDataPresent(insuranceData)
                ? createGraphRequestForAddOnProducts(
                        applicationId, insuranceData, applicantMapping.getSfApplicantId(), offerId)
                : createRequestForInactiveInsuranceDetails(applicationId, offerId);

        logPayload(ADD_ON_PRODUCTS.getValue(), applicationId, graphRequest);

        if (CollectionUtils.isEmpty(graphRequest.getGraphs().getFirst().getCompositeRequest())) {
            log.info("[syncAddOnProducts] Add on products not found for for application id {} ", applicationId);
            return SfSyncResponse.builder().isSuccessful("true").build();
        }
        GraphResponseDetail sfResponse = sfClient.postToSf(graphRequest);

        SfSyncVo sfSyncVo = SfSyncVo.builder()
                .applicationId(applicationId)
                .offerId(selectedOffer.getOfferId())
                .applicationMapping(applicantMapping.getApplicationMapping())
                .build();

        insuredDetailHelper.setInsuredDetailMappingsMap(sfSyncVo, insuranceData);

        SfSyncResponse sfSyncResponse = parseSfResponse(sfResponse.getGraphs().getFirst(), sfSyncVo, ADD_ON_PRODUCTS);
        return parseIfResponseIsSuccessful(sfSyncResponse);
    }

    private boolean isInsuranceDataPresent(InsuranceResponse insuranceData) {
        return nonNull(insuranceData.mls()) || nonNull(insuranceData.mas());
    }

    private GraphRequest createRequestForInactiveInsuranceDetails(String applicationId, UUID offerId) {
        log.info("No insurance attached to the Application Id: {}.", applicationId);

        List<CompositeRequest> compositeRequest = new ArrayList<>();

        createInactiveRequestForPreviousOffers(applicationId, offerId, compositeRequest);
        insuredDetailHelper.addInsuredDetailMappings(applicationId, compositeRequest, null);

        Graphs graphs =
                Graphs.builder().graphId("1").compositeRequest(compositeRequest).build();
        List<Graphs> requestGraphs = Collections.singletonList(graphs);
        return GraphRequest.builder().graphs(requestGraphs).build();
    }

    private Optional<AddOnProductMapping> getMappingByOfferType(
            List<AddOnProductMapping> mappings, OfferType offerType) {
        return mappings.stream().filter(m -> m.getOfferType().equals(offerType)).findFirst();
    }

    private GraphRequest createGraphRequestForAddOnProducts(
            String applicationId, InsuranceResponse insuranceResponse, String applicantId, UUID offerId) {
        List<CompositeRequest> compositeRequest = new ArrayList<>();
        LoanApplication loanApplication = mapToLoanApplicationForAddOnProducts();
        compositeRequest.add(buildApplicationRequest(loanApplication, applicationId, sfApiVersion));

        createInactiveRequestForPreviousOffers(applicationId, offerId, compositeRequest);

        List<AddOnProductMapping> existingMappings = addOnProductMappingRepository.findByOfferIdAndOfferTypeIn(
                offerId, List.of(OfferType.MAS, OfferType.MLS));
        Optional<AddOnProductMapping> existingMls = getMappingByOfferType(existingMappings, OfferType.MLS);
        Optional<AddOnProductMapping> existingMas = getMappingByOfferType(existingMappings, OfferType.MAS);
        if (existingMas.isPresent() && isNull(insuranceResponse.mas())) {
            String sfProductId = existingMas.get().getSfAddOnProductId();
            log.info("Deleting the existing {} add on product id: {}", OfferType.MAS, sfProductId);
            CompositeRequest masUpdateRequest = buildAddOnProductUpdateRequest(
                    AddOnProduct.builder().isActive(Boolean.FALSE).build(), sfProductId, "1");
            compositeRequest.add(masUpdateRequest);
            compositeRequest.add(buildAddOnProductGetRequest("1"));
            existingMas.get().setIsActive(Boolean.FALSE);

            insuredDetailHelper.addInsuredDetailMappings(
                    applicationId, compositeRequest, masUpdateRequest.getReferenceId());
        }
        if (nonNull(insuranceResponse.mas())) {
            AddOnProduct addOnProduct = mapToAddOnProductForMas(insuranceResponse.mas(), applicantId);
            if (existingMas.isPresent()) {
                String sfAddOnProductId = existingMas.get().getSfAddOnProductId();
                log.info("Updating the existing {} add on product id: {}", OfferType.MAS, sfAddOnProductId);
                CompositeRequest masUpdateRequest =
                        buildAddOnProductUpdateRequestForMas(addOnProduct, sfAddOnProductId);
                compositeRequest.add(masUpdateRequest);
                compositeRequest.add(buildAddOnProductGetRequest("1"));

                insuredDetailHelper.addInsuredDetailMappings(
                        applicationId, compositeRequest, insuranceResponse.mas(), masUpdateRequest.getReferenceId());

            } else {
                log.info("Creating {} add on product", OfferType.MAS);
                CompositeRequest masCreateRequest = buildAddOnProductCreateRequestForMas(addOnProduct);
                compositeRequest.add(masCreateRequest);
                compositeRequest.add(buildAddOnProductGetRequest("1"));

                insuredDetailHelper.addInsuredDetailMappings(
                        applicationId, compositeRequest, insuranceResponse.mas(), masCreateRequest.getReferenceId());
            }
        }

        if (existingMls.isPresent() && isNull(insuranceResponse.mls())) {
            String sfProductId = existingMls.get().getSfAddOnProductId();
            log.info("Deleting the existing {} add on product id: {}", OfferType.MLS, sfProductId);
            compositeRequest.add(buildAddOnProductUpdateRequest(
                    AddOnProduct.builder().isActive(Boolean.FALSE).build(), sfProductId, "2"));
            compositeRequest.add(buildAddOnProductGetRequest("2"));
        }
        if (nonNull(insuranceResponse.mls())) {
            AddOnProduct addOnProduct = mapToAddOnProductForMls(insuranceResponse.mls(), applicantId);
            if (existingMls.isPresent()) {
                String sfAddOnProductId = existingMls.get().getSfAddOnProductId();
                log.info("Updating the existing {} add on product id: {}", OfferType.MLS, sfAddOnProductId);
                compositeRequest.add(buildAddOnProductUpdateRequestForMls(addOnProduct, sfAddOnProductId));
            } else {
                log.info("Creating {} add on product", OfferType.MAS);
                compositeRequest.add(buildAddOnProductCreateRequestForMls(addOnProduct));
            }
            compositeRequest.add(buildAddOnProductGetRequest("2"));
        }

        Graphs graphs =
                Graphs.builder().graphId("1").compositeRequest(compositeRequest).build();
        List<Graphs> requestGraphs = Collections.singletonList(graphs);
        return GraphRequest.builder().graphs(requestGraphs).build();
    }

    private void createInactiveRequestForPreviousOffers(
            String applicationId, UUID offerId, List<CompositeRequest> compositeRequest) {
        List<AddOnProductMapping> oldExistingMappings =
                addOnProductMappingRepository.findByApplicationMappingApplicationIdAndOfferTypeIn(
                        applicationId, List.of(OfferType.MAS, OfferType.MLS));
        List<AddOnProductMapping> inactiveAddOnProducts = oldExistingMappings.stream()
                .filter(addOnProductMapping -> !offerId.equals(addOnProductMapping.getOfferId()))
                .toList();
        AtomicInteger count = new AtomicInteger(1);
        inactiveAddOnProducts.forEach(inactiveAddOnProduct -> {
            String inactiveSfAddOnProductId = inactiveAddOnProduct.getSfAddOnProductId();
            log.info("Deleting the existing {} add on product id: {}", OfferType.MLS, inactiveSfAddOnProductId);
            String refCount = "Inactive" + count.getAndIncrement();
            compositeRequest.add(buildAddOnProductUpdateRequest(
                    AddOnProduct.builder().isActive(Boolean.FALSE).build(), inactiveSfAddOnProductId, refCount));
            compositeRequest.add(buildAddOnProductGetRequest(refCount));
            inactiveAddOnProduct.setIsActive(Boolean.FALSE);
        });
    }

    private SfSyncResponse syncQde1DataToSf(String applicationId) {
        try {
            log.info("SalesForce data sync has been started for the Application Id: {}.", applicationId);
            LoanInfoResponse loanInfoResponse =
                    loanClient.fetchActiveLoanDetails(applicationId).getData();
            Map<String, MfResponse<List<KycResponse>>> kycDetailsListCoAppAndGuarantorMap = new HashMap<>();
            Map<String, CustomerResponse> customerResponseMap = new HashMap<>();
            Map<String, MfResponse<ConsentResponse>> consentResponseMap = new HashMap<>();
            Map<String, CopyOnWriteArrayList<Document>> docResponseMap = new ConcurrentHashMap<>();
            Map<String, CustomerDetailsResponse> stringCustomerDetailsResponseMap = new HashMap<>();

            Map<String, SfSyncVo> syncVoArrayMap = new ConcurrentHashMap<>();

            MfResponse<LoanDetailsResponse> loanDetailsResponse = loanClient.fetchLoanDetails(applicationId);

            CustomerDetailsResponse loanCustomerDetailsResponse = getPrimaryCustomer(loanDetailsResponse.getData());

            List<CustomerDetailsResponse> coApplicatanDetailsResponse =
                    getCoApplicantCustomer(loanDetailsResponse.getData());

            List<CustomerDetailsResponse> guarantorDetailsResponse =
                    getGuarantorCustomer(loanDetailsResponse.getData());

            coApplicatanDetailsResponse.forEach(t -> stringCustomerDetailsResponseMap.put(
                    t.getCustomerId().toString() + SFDC_KEY_SEPARATOR + CO_APPLICANT, t));
            guarantorDetailsResponse.forEach(t -> stringCustomerDetailsResponseMap.put(
                    t.getCustomerId().toString() + SFDC_KEY_SEPARATOR + GUARANTOR, t));

            coApplicatanDetailsResponse.forEach(t -> kycDetailsListCoAppAndGuarantorMap.put(
                    t.getCustomerId().toString() + SFDC_KEY_SEPARATOR + CO_APPLICANT,
                    kycClient.fetchKycDetails(t.getCustomerId())));

            guarantorDetailsResponse.forEach(t -> kycDetailsListCoAppAndGuarantorMap.put(
                    t.getCustomerId().toString() + SFDC_KEY_SEPARATOR + GUARANTOR,
                    kycClient.fetchKycDetails(t.getCustomerId())));

            UUID customerId = loanCustomerDetailsResponse.getCustomerId();

            kycDetailsListCoAppAndGuarantorMap.put(
                    customerId.toString() + SFDC_KEY_SEPARATOR + PRIMARY_APPLICANT,
                    kycClient.fetchKycDetails(loanCustomerDetailsResponse.getCustomerId()));

            Map<String, UUID> customerIds =
                    new HashMap<>(Map.of(customerId + SFDC_KEY_SEPARATOR + PRIMARY_APPLICANT, customerId));

            coApplicatanDetailsResponse.forEach(t -> customerIds.put(
                    t.getCustomerId().toString() + SFDC_KEY_SEPARATOR + CO_APPLICANT, t.getCustomerId()));
            guarantorDetailsResponse.forEach(t ->
                    customerIds.put(t.getCustomerId().toString() + SFDC_KEY_SEPARATOR + GUARANTOR, t.getCustomerId()));

            customerIds.forEach((key, value) -> customerResponseMap.put(
                    key,
                    customerClient
                            .fetchCustomerDetails(
                                    value,
                                    Set.of(
                                            "ucicIdResponse",
                                            "nameStrengthResponse",
                                            "triangulationResponse",
                                            BUREAU_RESPONSE))
                            .getData()));

            LeadDetailsResponse leadDetailsResponse =
                    leadClient.fetchLeadDetails(loanInfoResponse.getLeadId()).getData();

            customerResponseMap.forEach((key, value) -> consentResponseMap.put(
                    key, consentClient.getConsentDetails(loanInfoResponse.getLeadId(), value.getMobileNumber())));

            UserDetails userDetails = userServiceClient
                    .fetchUserDetails(loanInfoResponse.getUserId())
                    .getData()
                    .user();

            DocResponse docResponse = documentClient
                    .fetchDmsDocIdMapping(loanInfoResponse.getLeadId())
                    .getData();

            KycVerificationDetailsResponse kycVerifiactDetailsResponse = getKycVerificationDetails(applicationId);

            List<Document> activeDocuments = docResponse.getActiveDocuments();

            for (Document document : activeDocuments) {
                List<String> docStreamForKey = docResponseMap.keySet().stream().toList();

                if (!CollectionUtils.isEmpty(docStreamForKey)
                        && docStreamForKey.contains(document.getCustomerUUID().toString())) {
                    CopyOnWriteArrayList<Document> documents =
                            docResponseMap.get(document.getCustomerUUID().toString());
                    documents.add(document);
                    docResponseMap.put(document.getCustomerUUID().toString(), documents);
                } else {
                    CopyOnWriteArrayList<Document> onWriteArrayList = new CopyOnWriteArrayList<>();
                    onWriteArrayList.add(document);
                    docResponseMap.put(document.getCustomerUUID().toString(), onWriteArrayList);
                }
            }

            for (Map.Entry<String, CustomerResponse> customerResponseEntry : customerResponseMap.entrySet()) {
                String key = customerResponseEntry.getKey().split(SFDC_KEY_SEPARATOR)[0];
                if (!docResponseMap.isEmpty() && docResponseMap.containsKey(key)) {
                    CopyOnWriteArrayList<Document> toBeReplaced = docResponseMap.remove(key);
                    docResponseMap.put(customerResponseEntry.getKey(), toBeReplaced);
                }
            }

            Map<String, AmlResponse> amlResponseMap = new HashMap<>();

            customerResponseMap
                    .keySet()
                    .forEach(t -> amlResponseMap.put(
                            t,
                            customerClient
                                    .fetchAmlResponse(UUID.fromString(t.split(SFDC_KEY_SEPARATOR)[0]))
                                    .getData()));
            HunterResponse hunterResponse =
                    loanClient.fetchHunterDetails(applicationId).getData();

            AddOnProductResponse addOnProductResponse =
                    masterDataClient.getAddOnProducts().getData();

            GraphRequest graphRequest = createGraphRequestUptoQde1(
                    loanInfoResponse,
                    loanDetailsResponse.getData(),
                    kycDetailsListCoAppAndGuarantorMap,
                    loanCustomerDetailsResponse,
                    consentResponseMap,
                    customerResponseMap,
                    userDetails,
                    leadDetailsResponse,
                    docResponseMap,
                    amlResponseMap,
                    hunterResponse,
                    addOnProductResponse,
                    syncVoArrayMap,
                    stringCustomerDetailsResponseMap,
                    customerIds,
                    kycVerifiactDetailsResponse);

            logPayload(UPTO_QDE1.getValue(), applicationId, graphRequest);
            GraphResponseDetail sfResponse = sfClient.postToSf(graphRequest);
            SfSyncResponse sfSyncResponse = parseCoAppAndGuarantorAndApplicantSfResponse(
                    sfResponse.getGraphs().getFirst(), syncVoArrayMap, UPTO_QDE1);

            try {
                for (CustomerResponse customerResponse : customerResponseMap.values())
                    if (isProbableMatch(customerResponse))
                        syncDedupeExposure(applicationId, UUID.fromString(customerResponse.getCustomerId()));
            } catch (Exception e) {
                log.error("Unable to sync customer probable Matches - {}", e.getMessage());
            }
            return parseIfResponseIsSuccessful(sfSyncResponse);
        } catch (Exception exception) {
            log.error("Exception occurred while syncing QDE data to SalesForce", exception);
            throw exception;
        }
    }

    public static void logPayload(String stage, String applicationId, GraphRequest graphRequest) {
        try {
            log.debug(
                    "{} payload {} for application id {}",
                    stage,
                    new ObjectMapper().writeValueAsString(graphRequest),
                    applicationId);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    private static boolean isProbableMatch(CustomerResponse customerResponse) {
        return PARTIAL_MATCH.equals(getMatchType(customerResponse))
                || EXACT_MATCH.equals(getMatchType(customerResponse));
    }

    private void syncDedupeExposure(String applicationId, UUID customerId) {
        DedupeAndExposureResponse dedupeExposureData = customerClient.fetchDedupeAndExposure(customerId);
        Optional<ApplicantMapping> applicantMapping =
                applicantMappingRepository.findByApplicationMappingApplicationId(applicationId);
        String sfApplicantId =
                applicantMapping.map(ApplicantMapping::getSfApplicantId).orElse(null);
        if (isNull(sfApplicantId)) return;
        dedupeExposureData.setApplicantId(sfApplicantId);
        DedupeExposureRequest dedupeExposureRequest = DedupeExposureRequest.builder()
                .applicationId(applicationId)
                .data(List.of(dedupeExposureData))
                .build();
        try {
            log.debug("dedupeExposureRequest = {}", new ObjectMapper().writeValueAsString(dedupeExposureRequest));
        } catch (Exception e) {
            log.error(e.getMessage());
        }
        sfClient.syncDedupeExposure(dedupeExposureRequest);
    }

    private GraphRequest createGraphRequestUptoQde1(
            LoanInfoResponse loanInfo,
            LoanDetailsResponse loanDetails,
            Map<String, MfResponse<List<KycResponse>>> kycDetails,
            CustomerDetailsResponse loanCustomerDetails,
            Map<String, MfResponse<ConsentResponse>> consentDetails,
            Map<String, CustomerResponse> customers,
            UserDetails userDetails,
            LeadDetailsResponse leadDetailsResponse,
            Map<String, CopyOnWriteArrayList<Document>> docDmsIdMappings,
            Map<String, AmlResponse> amlResponse,
            HunterResponse hunterResponse,
            AddOnProductResponse addOnProductResponse,
            Map<String, SfSyncVo> sfSyncVoMap,
            Map<String, CustomerDetailsResponse> stringCustomerDetailsResponseMap,
            Map<String, UUID> customerIds,
            KycVerificationDetailsResponse kycVerifiactDetailsResponse) {

        List<CompositeRequest> compositeRequest = new ArrayList<>();
        String applicationId = loanInfo.getApplicationId();
        LoanAssetMapping assetMapping = loanAssetMappingRepository
                .findByApplicationMappingApplicationId(applicationId)
                .orElse(null);

        // No need of any change
        LoanApplication loanApplication =
                mapToLoanApplication(loanDetails, loanInfo, userDetails, leadDetailsResponse, envVariable);

        customers.forEach((key, value) -> sfSyncVoMap.put(
                key,
                buildBasicSfSyncVo(
                        loanInfo.getApplicationId(),
                        customerIds.get(key),
                        docDmsIdMappings.get(key),
                        value.getAddresses(),
                        key.split(SFDC_KEY_SEPARATOR)[1])));

        AtomicReference<String> primaryApplicantKey = new AtomicReference<>();
        customers.keySet().stream()
                .filter(s -> s.endsWith(PRIMARY_APPLICANT) && !s.endsWith(CO_APPLICANT))
                .findFirst()
                .ifPresent(primaryApplicantKey::set);

        ApplicantMapping applicantMapping = applicantMappingRepository
                .findByApplicationMappingApplicationIdAndApplicantId(
                        applicationId, customerIds.get(primaryApplicantKey.get()))
                .orElse(null);

        Boolean isLoanIdRequiredInApplicantBody = isNull(applicantMapping) ? Boolean.TRUE : Boolean.FALSE;

        Applicant applicant = mapToApplicant(
                customers.get(primaryApplicantKey.get()),
                consentDetails.get(primaryApplicantKey.get()).getData(),
                loanCustomerDetails,
                kycDetails.get(primaryApplicantKey.get()).getData(),
                amlResponse.get(primaryApplicantKey.get()),
                hunterResponse,
                isLoanIdRequiredInApplicantBody,
                kycVerifiactDetailsResponse);
        compositeRequest.add(buildApplicationRequest(loanApplication, applicationId, sfApiVersion));

        BureauResponseMapping bureauResponseMapping = bureauResponseMappingRepository
                .findBureauResponseMappingByApplicationMappingApplicationIdAndApplicationMappingApplicantMappingListApplicantId(
                        applicationId, customerIds.get(primaryApplicantKey.get()));

        List<Applicant> coAppAndGuarantorList = new ArrayList<>();
        int i = 0;
        for (Map.Entry<String, CustomerResponse> kvEntry : customers.entrySet()) {
            if (!kvEntry.getKey().endsWith(PRIMARY_APPLICANT)
                    || kvEntry.getKey().endsWith(CO_APPLICANT)) {

                Applicant coApplicant = mapToCoApplicantAndGuarantor(
                        kvEntry.getValue(),
                        consentDetails.get(kvEntry.getKey()).getData(),
                        stringCustomerDetailsResponseMap,
                        kycDetails,
                        amlResponse.get(kvEntry.getKey()),
                        hunterResponse,
                        isLoanIdRequiredInApplicantBody,
                        kvEntry.getKey(),
                        kycVerifiactDetailsResponse);
                coAppAndGuarantorList.add(coApplicant);

                ApplicantMapping coAppAndGuarantorApplicantMapping = applicantMappingRepository
                        .findByApplicationMappingApplicationIdAndApplicantId(
                                applicationId, customerIds.get(kvEntry.getKey()))
                        .orElse(null);

                compositeRequest.add(buildCoApplicantAndGuarantorRequest(
                        coAppAndGuarantorList.get(i),
                        coAppAndGuarantorApplicantMapping,
                        coAppAndGuarantorList.get(i).getApplicantType(),
                        String.valueOf(i)));
                BureauResponseMapping bureauResponseMappingCoAppAndGuarantor = bureauResponseMappingRepository
                        .findBureauResponseMappingByApplicationMappingApplicationIdAndApplicationMappingApplicantMappingListApplicantId(
                                applicationId, customerIds.get(kvEntry.getKey()));

                switch (coAppAndGuarantorList.get(i).getApplicantType()) {
                    case CO_APPLICANT -> {
                        String key = String.format(CREATE_CO_APPLICANT.getReferenceId(), i);
                        compositeRequest.add(buildGetCoApplicantRequest(
                                String.format(CREATE_CO_APPLICANT.getReferenceId(), i),
                                String.valueOf(i),
                                kvEntry.getKey(),
                                sfSyncVoMap));

                        buildCoAppAndGuarantorAddressCompositeRequests(
                                compositeRequest,
                                customers.get(kvEntry.getKey()).getAddresses(),
                                customers.get(kvEntry.getKey()).getAddressMatchStrengthResponse(),
                                coAppAndGuarantorApplicantMapping,
                                sfSyncVoMap,
                                key,
                                CO_APPLICANT);
                        if (isCibilDetailsAvailable(customers.get(kvEntry.getKey()))) {
                            CompositeRequest compositeRequest1 = buildCoAppAndGuarantorBureauResponse(
                                    mapToCoAppAndGuarantorToBureauResponse(customers.get(kvEntry.getKey()), key),
                                    bureauResponseMappingCoAppAndGuarantor,
                                    CO_APPLICANT,
                                    key);
                            compositeRequest.add(compositeRequest1);
                            compositeRequest.add(buildCoAppAndGuarantorGetBureauResponse(
                                    CO_APPLICANT, compositeRequest1.getReferenceId(), key));

                            List<Document> documentList = docDmsIdMappings.get(kvEntry.getKey());

                            documentList.forEach(docDmsIdMapping -> {
                                DocReferenceIdMapping referenceIdMapping = docReferenceIdMappingRepository
                                        .findByDocReferenceId(docDmsIdMapping.getDocReferenceId())
                                        .orElseThrow(() -> new InvalidRequestException(INVALID_DOC_REFERENCE_ID));

                                DocumentChecklist documentChecklist = mapToCoAppAndGuarantorDocumentChecklistForQde(
                                        docDmsIdMapping,
                                        referenceIdMapping,
                                        key,
                                        CO_APPLICANT,
                                        extractNumberFromRefereenceId(key));

                                String docChecklistId = checklistIdMappingRepository
                                        .getFirstByDocServiceUuidOrderByCreatedAtDesc(
                                                UUID.fromString(docDmsIdMapping.getDocId()))
                                        .map(ChecklistIdMapping::getSfDocChecklistId)
                                        .orElse(null);

                                compositeRequest.add(buildDocumentCheckList(documentChecklist, docChecklistId));

                                if (isNull(docChecklistId))
                                    compositeRequest.add(buildGetDocumentCheckListRequest(
                                            documentChecklist, kvEntry.getKey(), sfSyncVoMap));
                            });
                        }
                    }
                    case GUARANTOR -> {
                        String key = String.format(CREATE_GUARANTOR.getReferenceId(), i);
                        compositeRequest.add(buildGetGuarantorRequest(
                                String.format(CREATE_GUARANTOR.getReferenceId(), i),
                                String.valueOf(i),
                                kvEntry.getKey(),
                                sfSyncVoMap));
                        buildCoAppAndGuarantorAddressCompositeRequests(
                                compositeRequest,
                                customers.get(kvEntry.getKey()).getAddresses(),
                                customers.get(kvEntry.getKey()).getAddressMatchStrengthResponse(),
                                coAppAndGuarantorApplicantMapping,
                                sfSyncVoMap,
                                key,
                                GUARANTOR);
                        if (isCibilDetailsAvailable(customers.get(kvEntry.getKey()))) {
                            CompositeRequest compositeRequest1 = buildCoAppAndGuarantorBureauResponse(
                                    mapToCoAppAndGuarantorToBureauResponse(customers.get(kvEntry.getKey()), key),
                                    bureauResponseMappingCoAppAndGuarantor,
                                    GUARANTOR,
                                    key);
                            compositeRequest.add(compositeRequest1);
                            compositeRequest.add(buildCoAppAndGuarantorGetBureauResponse(
                                    GUARANTOR, compositeRequest1.getReferenceId(), key));

                            List<Document> documentList = docDmsIdMappings.get(kvEntry.getKey());
                            documentList.forEach(docDmsIdMapping -> {
                                DocReferenceIdMapping referenceIdMapping = docReferenceIdMappingRepository
                                        .findByDocReferenceId(docDmsIdMapping.getDocReferenceId())
                                        .orElseThrow(() -> new InvalidRequestException(INVALID_DOC_REFERENCE_ID));
                                DocumentChecklist documentChecklist = mapToCoAppAndGuarantorDocumentChecklistForQde(
                                        docDmsIdMapping,
                                        referenceIdMapping,
                                        key,
                                        GUARANTOR,
                                        extractNumberFromRefereenceId(key));

                                String docChecklistId = checklistIdMappingRepository
                                        .getFirstByDocServiceUuidOrderByCreatedAtDesc(
                                                UUID.fromString(docDmsIdMapping.getDocId()))
                                        .map(ChecklistIdMapping::getSfDocChecklistId)
                                        .orElse(null);

                                compositeRequest.add(buildDocumentCheckList(documentChecklist, docChecklistId));
                                if (isNull(docChecklistId))
                                    compositeRequest.add(buildGetDocumentCheckListRequest(
                                            documentChecklist, kvEntry.getKey(), sfSyncVoMap));
                            });
                        }
                    }
                    default -> throw new IllegalStateException(
                            "Unexpected value: " + coAppAndGuarantorList.get(i).getApplicantType());
                }
                i++;
            }
        }
        compositeRequest.add(buildApplicantRequest(applicant, applicantMapping));

        if (isCibilDetailsAvailable(customers.get(primaryApplicantKey.get()))) {
            compositeRequest.add(buildBureauResponse(
                    mapToBureauResponse(customers.get(primaryApplicantKey.get())), bureauResponseMapping));
            compositeRequest.add(buildGetBureauResponse());
        }

        docDmsIdMappings.get(primaryApplicantKey.get()).forEach(docDmsIdMapping -> {
            DocReferenceIdMapping referenceIdMapping = docReferenceIdMappingRepository
                    .findByDocReferenceId(docDmsIdMapping.getDocReferenceId())
                    .orElseThrow(() -> new InvalidRequestException(INVALID_DOC_REFERENCE_ID));
            DocumentChecklist documentChecklist = mapToDocumentChecklistForQde(docDmsIdMapping, referenceIdMapping);

            String docChecklistId = checklistIdMappingRepository
                    .getFirstByDocServiceUuidOrderByCreatedAtDesc(UUID.fromString(docDmsIdMapping.getDocId()))
                    .map(ChecklistIdMapping::getSfDocChecklistId)
                    .orElse(null);

            compositeRequest.add(buildDocumentCheckList(documentChecklist, docChecklistId));
            if (isNull(docChecklistId))
                compositeRequest.add(
                        buildGetDocumentCheckListRequest(documentChecklist, primaryApplicantKey.get(), sfSyncVoMap));
        });

        List<AddressResponse> addressDetails =
                customers.get(primaryApplicantKey.get()).getAddresses();
        buildAddressCompositeRequests(
                compositeRequest,
                addressDetails,
                customers.get(primaryApplicantKey.get()).getAddressMatchStrengthResponse(),
                applicantMapping,
                primaryApplicantKey.get(),
                sfSyncVoMap);

        compositeRequest.add(buildGetApplicantRequest(primaryApplicantKey.get(), sfSyncVoMap));
        compositeRequest.add(buildLoanAssetRequest(mapToLoanAsset(loanDetails, null), assetMapping, sfApiVersion));
        compositeRequest.add(buildGetAssetRequest());

        payoutRequestHandler.addPayoutRequests(applicationId, loanDetails, compositeRequest);
        createCompositeRequestsForAddOnProducts(loanInfo, loanDetails, addOnProductResponse, compositeRequest);

        Graphs graph =
                Graphs.builder().graphId("1").compositeRequest(compositeRequest).build();
        return GraphRequest.builder().graphs(Collections.singletonList(graph)).build();
    }

    private void addQdeTwoQdeThreeInactiveCompositeRequests(
            String applicationId, List<CompositeRequest> compositeRequest) {
        List<CompositeRequest> inactiveApplicantFinancialsCompositeRequests =
                applicantFinancialsRequestHandler.buildCompositeRequestsForQdeOneSync(applicationId);
        List<CompositeRequest> inactiveViabilityTemplateCompositeRequests =
                incomeAssessmentRequestHandler.buildCompositeRequestsForQdeOneSync(applicationId);

        compositeRequest.addAll(inactiveApplicantFinancialsCompositeRequests);
        compositeRequest.addAll(inactiveViabilityTemplateCompositeRequests);
    }

    private void createCompositeRequestsForAddOnProducts(
            LoanInfoResponse loanInfo,
            LoanDetailsResponse loanDetails,
            AddOnProductResponse addOnProductResponse,
            List<CompositeRequest> compositeRequest) {
        int count = 1;
        List<AssetAddOnProductResponse> requestList = loanDetails.getAssetInfo().getAddOnProducts();
        List<AddOnProductMapping> dbList =
                addOnProductMappingRepository.findByApplicationMappingApplicationIdAndOfferTypeAndIsActive(
                        loanInfo.getApplicationId(), OfferType.OTHER, Boolean.TRUE);

        for (AssetAddOnProductResponse request : requestList) {
            AddOnProductMapping dbRecord = dbList.stream()
                    .filter(i -> i.getProductCode().equals(request.getType()))
                    .findFirst()
                    .orElse(null);
            // PATCH
            if (dbRecord != null) {
                compositeRequest.add(buildAddOnProductUpdateRequest(
                        mapToAddOnProduct(request, addOnProductResponse),
                        dbRecord.getSfAddOnProductId(),
                        String.valueOf(count)));
                count++;
            }
        }

        for (AssetAddOnProductResponse request : requestList) {
            if (dbList.isEmpty()
                    || dbList.stream().noneMatch(i -> i.getProductCode().equals(request.getType()))) {
                // POST
                compositeRequest.add(buildAddOnProductRequest(mapToAddOnProduct(request, addOnProductResponse), count));
                compositeRequest.add(buildAddOnProductGetRequest(String.valueOf(count)));
                count++;
            }
        }

        for (AddOnProductMapping dbRecord : dbList) {
            if (requestList.stream().noneMatch(i -> i.getType().equals(dbRecord.getProductCode()))) {
                // DELETE
                compositeRequest.add(buildAddOnProductDeleteRequest(
                        AddOnProduct.builder().isActive(Boolean.FALSE).build(), dbRecord.getSfAddOnProductId(), count));
                dbRecord.setIsActive(false);
                addOnProductMappingRepository.save(dbRecord);
                count++;
            }
        }
    }

    public SfSyncResponse syncPostSanctionDataToSf(String applicationId) {
        try {
            log.info(
                    "SalesForce data sync for post sanction stage has been started for the Application Id: {}.",
                    applicationId);
            ApplicationMapping applicationMapping = applicationMappingRepository
                    .findByApplicationId(applicationId)
                    .orElseThrow(() -> new InvalidRequestException(SF_APPLICATION_MAPPING_NOT_FOUND));
            MfResponse<LoanDetailsResponse> loanDetailsResponse = loanClient.fetchLoanDetails(applicationId);
            LoanDetailsResponse loanDetails = loanDetailsResponse.getData();
            MfResponse<PostSanctionLoanResponse> postSanctionLoanResponse =
                    loanClient.fetchPostSanctionLoanDetails(applicationId);

            UUID rePayerCustomerId = loanDetailsResponse.getData().getLoanInfo().getRePayerCustomerId();
            ApplicantMapping applicantMapping = applicationMapping.getApplicantMappingList().stream()
                    .filter(mapping -> mapping.getApplicantId().equals(rePayerCustomerId))
                    .findFirst()
                    .orElseThrow(() -> new InvalidRequestException(APPLICANT_NOT_FOUND_FOR_GIVEN_APPLICATION_ID));
            CustomerResponse customerResponse = customerClient
                    .fetchCustomerDetails(rePayerCustomerId, Set.of("ucicIdResponse"))
                    .getData();

            MfResponse<DisbursementBankDetailResponse> disbursementBankDetailResponse = null;
            BankingResponse bankingResponse = postSanctionLoanResponse.getData().getBankingResponse();
            if (nonNull(bankingResponse)) {
                UUID ifscCodeUuid = bankingResponse.getIfscCodeUuid();
                disbursementBankDetailResponse = masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid);
            }

            MfResponse<AccountVerificationDetailsResponse> accountVerificationDetailsResponse =
                    loanClient.fetchAccountVerificationDetails(applicationId, rePayerCustomerId.toString());

            MfResponse<IHMResponse> ihmResponse =
                    loanClient.fetchLoanChargeDetails(applicationId, rePayerCustomerId.toString());
            OfferResponse offers =
                    offerClient.getOffers(applicationId, Boolean.TRUE).getData();
            OfferDetails selectedOffer = offers.getOfferList().getFirst();

            SfSyncVo sfSyncVo = SfSyncVo.builder()
                    .rePayerCustomerId(
                            loanDetailsResponse.getData().getLoanInfo().getRePayerCustomerId())
                    .bankDetailsId(Objects.isNull(bankingResponse) ? null : bankingResponse.getId())
                    .applicationMapping(applicantMapping.getApplicationMapping())
                    .fosAddresses(customerResponse.getAddresses())
                    .build();

            GraphRequest graphRequest = createGraphRequestForDde(
                    postSanctionLoanResponse,
                    customerResponse,
                    applicationId,
                    disbursementBankDetailResponse,
                    accountVerificationDetailsResponse,
                    ihmResponse,
                    selectedOffer,
                    applicantMapping,
                    loanDetails,
                    sfSyncVo);
            logPayload(DDE.getValue(), applicationId, graphRequest);
            GraphResponseDetail sfResponse = sfClient.postToSf(graphRequest);
            SfSyncResponse sfSyncResponse =
                    parseSfResponse(sfResponse.getGraphs().getFirst(), sfSyncVo, DDE);
            return parseIfResponseIsSuccessful(sfSyncResponse);
        } catch (Exception exception) {
            log.error("Exception occurred while syncing post sanction stage data to SalesForce", exception);
            throw exception;
        }
    }

    public SfSyncResponse syncCoAppAndGuarantorPostSanctionDataToSf(String applicationId) {
        try {
            log.info(
                    "SalesForce data sync for post sanction stage Co App And Guarantor has been started for the Application Id: {}.",
                    applicationId);
            Map<String, CustomerResponse> customerResponseMap = new HashMap<>();
            Map<String, SfSyncVo> sfSyncVoMap = new HashMap<>();
            Map<String, ApplicantMapping> applicantMapping = new HashMap<>();
            ApplicationMapping applicationMapping = applicationMappingRepository
                    .findByApplicationId(applicationId)
                    .orElseThrow(() -> new InvalidRequestException(SF_APPLICATION_MAPPING_NOT_FOUND));
            MfResponse<LoanDetailsResponse> loanDetailsResponse = loanClient.fetchLoanDetails(applicationId);
            LoanDetailsResponse loanDetails = loanDetailsResponse.getData();
            MfResponse<PostSanctionLoanResponse> postSanctionLoanResponse =
                    loanClient.fetchPostSanctionLoanDetails(applicationId);

            List<ApplicantMapping> applicantMappings = applicationMapping.getApplicantMappingList();
            for (ApplicantMapping mapping : applicantMappings) {
                applicantMapping.put(mapping.getApplicantId().toString(), mapping);
            }

            UUID rePayerCustomerId = loanDetailsResponse.getData().getLoanInfo().getRePayerCustomerId();
            // Get All Applicants from mapping table
            applicantMappings.forEach(t -> customerResponseMap.put(
                    t.getApplicantId().toString(),
                    customerClient
                            .fetchCustomerDetails(t.getApplicantId(), Set.of("ucicIdResponse"))
                            .getData()));

            ApplicantMapping rePayerApplicantMapping = applicationMapping.getApplicantMappingList().stream()
                    .filter(mapping -> mapping.getApplicantId().equals(rePayerCustomerId))
                    .findFirst()
                    .orElseThrow(() -> new InvalidRequestException(APPLICANT_NOT_FOUND_FOR_GIVEN_APPLICATION_ID));

            MfResponse<DisbursementBankDetailResponse> disbursementBankDetailResponse = null;
            BankingResponse bankingResponse = postSanctionLoanResponse.getData().getBankingResponse();
            if (nonNull(bankingResponse)) {
                UUID ifscCodeUuid = bankingResponse.getIfscCodeUuid();
                disbursementBankDetailResponse = masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid);
            }

            MfResponse<AccountVerificationDetailsResponse> accountVerificationDetailsResponse =
                    MfResponse.ok(new AccountVerificationDetailsResponse());
            // loanClient.fetchAccountVerificationDetails(applicationId, rePayerCustomerId.toString());

            MfResponse<IHMResponse> ihmResponse =
                    loanClient.fetchLoanChargeDetails(applicationId, rePayerCustomerId.toString());
            OfferResponse offers =
                    offerClient.getOffers(applicationId, Boolean.TRUE).getData();
            OfferDetails selectedOffer = offers.getOfferList().getFirst();

            customerResponseMap.forEach((key, value) -> sfSyncVoMap.put(
                    key,
                    SfSyncVo.builder()
                            .rePayerCustomerId(
                                    loanDetailsResponse.getData().getLoanInfo().getRePayerCustomerId())
                            .bankDetailsId(Objects.isNull(bankingResponse) ? null : bankingResponse.getId())
                            .applicationMapping(rePayerApplicantMapping.getApplicationMapping())
                            .fosAddresses(value.getAddresses())
                            .applicantId(UUID.fromString(key))
                            .build()));

            GraphRequest graphRequest = createCoAppAndGuarantorGraphRequestForDde(
                    postSanctionLoanResponse,
                    customerResponseMap,
                    applicationId,
                    disbursementBankDetailResponse,
                    accountVerificationDetailsResponse,
                    ihmResponse,
                    selectedOffer,
                    applicantMapping,
                    loanDetails,
                    sfSyncVoMap,
                    rePayerCustomerId);
            logPayload(DDE.getValue(), applicationId, graphRequest);
            GraphResponseDetail sfResponse = sfClient.postToSf(graphRequest);
            SfSyncResponse sfSyncResponse = parseCoAppAndGuarantorAndApplicantSfResponse(
                    sfResponse.getGraphs().getFirst(), sfSyncVoMap, DDE);
            return parseIfResponseIsSuccessful(sfSyncResponse);
        } catch (Exception exception) {
            log.error("Exception occurred while syncing post sanction stage data to SalesForce", exception);
            throw exception;
        }
    }

    private GraphRequest createGraphRequestForDde(
            MfResponse<PostSanctionLoanResponse> postSanctionLoanResponse,
            CustomerResponse customerResponse,
            String applicationId,
            MfResponse<DisbursementBankDetailResponse> disbursementBankDetailResponse,
            MfResponse<AccountVerificationDetailsResponse> accountVerificationDetailsResponse,
            MfResponse<IHMResponse> ihmResponse,
            OfferDetails offerDetails,
            ApplicantMapping applicantMapping,
            LoanDetailsResponse loanDetails,
            SfSyncVo sfSyncVo) {
        List<CompositeRequest> compositeRequest = createCompositeRequestForDde(
                postSanctionLoanResponse.getData(),
                customerResponse,
                applicationId,
                disbursementBankDetailResponse,
                accountVerificationDetailsResponse,
                ihmResponse.getData(),
                offerDetails,
                applicantMapping,
                loanDetails.getLoanInfo(),
                sfSyncVo);

        payoutRequestHandler.addUpdatePayoutDetailsRequest(applicationId, loanDetails, compositeRequest);

        Graphs graph =
                Graphs.builder().graphId("1").compositeRequest(compositeRequest).build();
        return GraphRequest.builder().graphs(Collections.singletonList(graph)).build();
    }

    private GraphRequest createCoAppAndGuarantorGraphRequestForDde(
            MfResponse<PostSanctionLoanResponse> postSanctionLoanResponse,
            Map<String, CustomerResponse> customerResponseMap,
            String applicationId,
            MfResponse<DisbursementBankDetailResponse> disbursementBankDetailResponse,
            MfResponse<AccountVerificationDetailsResponse> accountVerificationDetailsResponse,
            MfResponse<IHMResponse> ihmResponse,
            OfferDetails offerDetails,
            Map<String, ApplicantMapping> applicantMappings,
            LoanDetailsResponse loanDetails,
            Map<String, SfSyncVo> sfSyncVoMap,
            UUID rePayerCustomerId) {
        List<CompositeRequest> compositeRequest = createCoAppAndGuarantorCompositeRequestForDde(
                postSanctionLoanResponse.getData(),
                customerResponseMap,
                applicationId,
                disbursementBankDetailResponse,
                accountVerificationDetailsResponse,
                ihmResponse.getData(),
                offerDetails,
                applicantMappings,
                loanDetails,
                sfSyncVoMap,
                rePayerCustomerId);

        payoutRequestHandler.addUpdatePayoutDetailsRequest(applicationId, loanDetails, compositeRequest);

        Graphs graph =
                Graphs.builder().graphId("1").compositeRequest(compositeRequest).build();
        return GraphRequest.builder().graphs(Collections.singletonList(graph)).build();
    }

    private List<CompositeRequest> createCompositeRequestForDde(
            PostSanctionLoanResponse postSanctionLoan,
            CustomerResponse customerResponse,
            String applicationId,
            MfResponse<DisbursementBankDetailResponse> disbursementBankDetail,
            MfResponse<AccountVerificationDetailsResponse> accountVerificationDetailsResponse,
            IHMResponse ihmResponse,
            OfferDetails offerDetails,
            ApplicantMapping applicantMapping,
            LoanResponse loanInfo,
            SfSyncVo sfSyncVo) {
        List<CompositeRequest> compositeRequest = new ArrayList<>();

        PostSanctionLoanApplication postSanctionLoanApplication =
                mapToPostSanctionLoanApplication(postSanctionLoan, offerDetails);
        PostSanctionApplicant postSanctionApplicant =
                mapToPostSanctionApplicant(customerResponse, postSanctionLoan.getPslResponse());

        List<OverDueCharge> overDueCharges = ihmResponse.getOverDueChargeList();
        List<ChargeMapping> existingChargeMappingList = getChargeMappingsByApplicationId(applicationId);
        compositeRequest.add(buildPostSanctionApplicationRequest(postSanctionLoanApplication, applicationId));
        buildCompositeRequestForLoanCharge(
                ihmResponse, compositeRequest, overDueCharges, existingChargeMappingList, sfSyncVo);
        String bankDetailsFor =
                loanInfo.getRePayerCustomerId().equals(applicantMapping.getApplicantId()) ? "Borrower" : "Co-Borrower";

        if (nonNull(postSanctionLoan.getBankingResponse())) {
            BankingDetail bankingDetail = mapToBankingDetail(
                    postSanctionLoan.getBankingResponse(),
                    customerResponse,
                    disbursementBankDetail.getData(),
                    accountVerificationDetailsResponse.getData(),
                    applicantMapping.getSfApplicantId(),
                    bankDetailsFor);

            BankDetailsMapping bankDetailsMapping = bankDetailsMappingRepository
                    .findBankDetailsMappingByApplicationMappingApplicationId(applicationId)
                    .orElse(null);
            compositeRequest.add(buildBankingRequest(bankingDetail, bankDetailsMapping));
            compositeRequest.add(buildGetBankingRequest());
        }

        compositeRequest.add(
                buildPostSanctionApplicantRequest(postSanctionApplicant, applicantMapping.getSfApplicantId()));
        return compositeRequest;
    }

    private List<CompositeRequest> createCoAppAndGuarantorCompositeRequestForDde(
            PostSanctionLoanResponse postSanctionLoan,
            Map<String, CustomerResponse> customerResponseMap,
            String applicationId,
            MfResponse<DisbursementBankDetailResponse> disbursementBankDetail,
            MfResponse<AccountVerificationDetailsResponse> accountVerificationDetailsResponse,
            IHMResponse ihmResponse,
            OfferDetails offerDetails,
            Map<String, ApplicantMapping> applicantMappings,
            LoanDetailsResponse loanDetailsResponse,
            Map<String, SfSyncVo> sfSyncVo,
            UUID rePayerCustomerId) {
        List<CompositeRequest> compositeRequest = new ArrayList<>();

        PostSanctionLoanApplication postSanctionLoanApplication =
                mapToPostSanctionLoanApplication(postSanctionLoan, offerDetails);

        List<PostSanctionApplicant> postSanctionApplicants = mapToCoAppAndGuarantorPostSanctionApplicant(
                customerResponseMap,
                postSanctionLoan.getPslResponse(),
                getPrimaryCustomer(loanDetailsResponse).getCustomerId().toString());

        List<OverDueCharge> overDueCharges = ihmResponse.getOverDueChargeList();
        List<ChargeMapping> existingChargeMappingList = getChargeMappingsByApplicationId(applicationId);
        compositeRequest.add(buildPostSanctionApplicationRequest(postSanctionLoanApplication, applicationId));
        buildCoAppAndGuarantorCompositeRequestForLoanCharge(
                ihmResponse, compositeRequest, overDueCharges, existingChargeMappingList, sfSyncVo, rePayerCustomerId);
        String bankDetailsFor = loanDetailsResponse
                        .getLoanInfo()
                        .getRePayerCustomerId()
                        .equals(applicantMappings
                                .get(rePayerCustomerId.toString())
                                .getApplicantId())
                ? "Borrower"
                : "Co-Borrower";

        if (nonNull(postSanctionLoan.getBankingResponse())) {
            BankingDetail bankingDetail = mapToBankingDetail(
                    postSanctionLoan.getBankingResponse(),
                    customerResponseMap.get(rePayerCustomerId.toString()),
                    disbursementBankDetail.getData(),
                    accountVerificationDetailsResponse.getData(),
                    applicantMappings.get(rePayerCustomerId.toString()).getSfApplicantId(),
                    bankDetailsFor);

            BankDetailsMapping bankDetailsMapping = bankDetailsMappingRepository
                    .findBankDetailsMappingByApplicationMappingApplicationId(applicationId)
                    .orElse(null);
            compositeRequest.add(buildBankingRequest(bankingDetail, bankDetailsMapping));
            compositeRequest.add(buildGetBankingRequest());
        }
        int i = 0;
        for (PostSanctionApplicant postSanctionApplicant : postSanctionApplicants) {
            compositeRequest.add(buildCoAppAndGuarantorPostSanctionApplicantRequest(
                    postSanctionApplicant,
                    applicantMappings
                            .get(postSanctionApplicant.getApplicantId())
                            .getSfApplicantId(),
                    i));
            i++;
        }

        return compositeRequest;
    }

    private void buildCompositeRequestForLoanCharge(
            IHMResponse ihmResponse,
            List<CompositeRequest> compositeRequest,
            List<OverDueCharge> overDueCharges,
            List<ChargeMapping> existingChargeMappingList,
            SfSyncVo sfSyncVo) {
        overDueCharges.forEach(overDueCharge -> {
            LoanCharge loanCharge = mapToLoanChargeForDde(overDueCharge, ihmResponse.getApplicationId());
            Optional<ChargeMapping> existingChargeMapping = existingChargeMappingList.stream()
                    .filter(chargeMapping -> chargeMapping
                            .getChargeId()
                            .equals(overDueCharge.getTransactionCode().toString()))
                    .findAny();
            String sfChargeId =
                    existingChargeMapping.map(ChargeMapping::getSfChargeId).orElse(null);
            compositeRequest.add(buildLoanChargeRequest(loanCharge, sfChargeId));
            compositeRequest.add(buildGetLoanChargeRequest(loanCharge));
        });

        List<ChargeMapping> chargeMappingsToBeDeleted =
                getChargeMappingsToBeDeleted(overDueCharges, existingChargeMappingList);
        sfSyncVo.setChargeMappingsToBeDeleted(chargeMappingsToBeDeleted);
        chargeMappingsToBeDeleted.forEach(chargeMapping -> compositeRequest.add(buildLoanChargeRequest(
                LoanCharge.builder()
                        .loan(Map.of(APPLICATION_ID_C, ihmResponse.getApplicationId()))
                        .loanChargeMaster(Map.of(CHARGE_ID_C, chargeMapping.getChargeId()))
                        .isActive(Boolean.FALSE)
                        .build(),
                chargeMapping.getSfChargeId())));
    }

    private void buildCoAppAndGuarantorCompositeRequestForLoanCharge(
            IHMResponse ihmResponse,
            List<CompositeRequest> compositeRequest,
            List<OverDueCharge> overDueCharges,
            List<ChargeMapping> existingChargeMappingList,
            Map<String, SfSyncVo> sfSyncVo,
            UUID repayerId) {
        overDueCharges.forEach(overDueCharge -> {
            LoanCharge loanCharge = mapToLoanChargeForDde(overDueCharge, ihmResponse.getApplicationId());
            Optional<ChargeMapping> existingChargeMapping = existingChargeMappingList.stream()
                    .filter(chargeMapping -> chargeMapping
                            .getChargeId()
                            .equals(overDueCharge.getTransactionCode().toString()))
                    .findAny();
            String sfChargeId =
                    existingChargeMapping.map(ChargeMapping::getSfChargeId).orElse(null);
            compositeRequest.add(buildLoanChargeRequest(loanCharge, sfChargeId));
            compositeRequest.add(buildGetLoanChargeRequest(loanCharge));
        });

        List<ChargeMapping> chargeMappingsToBeDeleted =
                getChargeMappingsToBeDeleted(overDueCharges, existingChargeMappingList);
        sfSyncVo.get(repayerId.toString()).setChargeMappingsToBeDeleted(chargeMappingsToBeDeleted);
        chargeMappingsToBeDeleted.forEach(chargeMapping -> compositeRequest.add(buildLoanChargeRequest(
                LoanCharge.builder()
                        .loan(Map.of(APPLICATION_ID_C, ihmResponse.getApplicationId()))
                        .loanChargeMaster(Map.of(CHARGE_ID_C, chargeMapping.getChargeId()))
                        .isActive(Boolean.FALSE)
                        .build(),
                chargeMapping.getSfChargeId())));
    }

    @NotNull
    private static List<ChargeMapping> getChargeMappingsToBeDeleted(
            List<OverDueCharge> overDueCharges, List<ChargeMapping> existingChargeMappingList) {
        return existingChargeMappingList.stream()
                .filter(existingChargeMapping -> overDueCharges.stream().noneMatch(overDueCharge -> overDueCharge
                        .getTransactionCode()
                        .toString()
                        .equals(existingChargeMapping.getChargeId())))
                .toList();
    }

    @NotNull
    private List<ChargeMapping> getChargeMappingsByApplicationId(String applicationId) {
        return chargeMappingRepository
                .findByApplicationMappingApplicationId(applicationId)
                .orElse(new ArrayList<>());
    }

    private CustomerDetailsResponse getPrimaryCustomer(LoanDetailsResponse loanDetailsResponse) {
        if (Objects.isNull(loanDetailsResponse.getCustomerDetails())) {
            throw new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_CUSTOMER_DETAILS_INVALID_RESPONSE);
        }
        return loanDetailsResponse.getCustomerDetails().stream()
                .filter(customer -> customer.getCustomerType().equals(CustomerType.PRIMARY))
                .findAny()
                .orElseThrow(() -> new InvalidRequestException(PRIMARY_CUSTOMER_ID_NOT_FOUND));
    }

    private CompositeRequest buildLoanChargeRequest(LoanCharge loanCharge, String sfLoanChargeId) {
        boolean isSyncAlreadyDone = nonNull(sfLoanChargeId);
        String loanChargeId = loanCharge.getLoanChargeMaster().get(CHARGE_ID_C);
        return CompositeRequest.builder()
                .url(getSyncResourceUrl(
                        isSyncAlreadyDone, CREATE_LOAN_CHARGE, UPDATE_LOAN_CHARGE, sfLoanChargeId, sfApiVersion))
                .body(loanCharge)
                .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_LOAN_CHARGE, UPDATE_LOAN_CHARGE))
                .referenceId(String.format(CREATE_LOAN_CHARGE.getReferenceId(), loanChargeId))
                .build();
    }

    private List<CustomerDetailsResponse> getCoApplicantCustomer(LoanDetailsResponse loanDetailsResponse) {
        if (isNull(loanDetailsResponse.getCustomerDetails())) {
            throw new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_CUSTOMER_DETAILS_INVALID_RESPONSE);
        }
        return loanDetailsResponse.getCustomerDetails().stream()
                .filter(customer -> customer.getCustomerType().equals(CustomerType.COAPPLICANT))
                .toList();
    }

    private List<CustomerDetailsResponse> getGuarantorCustomer(LoanDetailsResponse loanDetailsResponse) {
        if (isNull(loanDetailsResponse.getCustomerDetails())) {
            throw new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_CUSTOMER_DETAILS_INVALID_RESPONSE);
        }
        return loanDetailsResponse.getCustomerDetails().stream()
                .filter(customer -> customer.getCustomerType().equals(CustomerType.GUARANTOR))
                .toList();
    }

    private CompositeRequest buildDocumentCheckList(DocumentChecklist document, String docChecklistId) {
        String sfDocChecklistId = Objects.isNull(docChecklistId) ? null : docChecklistId;
        boolean isSyncAlreadyDone = nonNull(docChecklistId);
        String referenceId = getModifiedReferenceId(CREATE_DOCUMENT_CHECKLIST, document.getDmsIdentifier());
        return CompositeRequest.builder()
                .url(getSyncResourceUrl(
                        isSyncAlreadyDone,
                        CREATE_DOCUMENT_CHECKLIST,
                        UPDATE_DOCUMENT_CHECKLIST,
                        sfDocChecklistId,
                        sfApiVersion))
                .body(document)
                .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_DOCUMENT_CHECKLIST, UPDATE_DOCUMENT_CHECKLIST))
                .referenceId(referenceId)
                .build();
    }

    private CompositeRequest buildGetApplicantRequest(String key, Map<String, SfSyncVo> sfSyncVoMap) {
        return CompositeRequest.builder()
                .url(String.format(GET_APPLICANT.getUrl(), sfApiVersion, CREATE_APPLICANT.getReferenceId()))
                .method(GET_APPLICANT.getMethod())
                .referenceId(GET_APPLICANT.getReferenceId())
                .build();
    }

    private CompositeRequest buildGetCoApplicantRequest(
            String paramReferenceId, String referenceId, String key, Map<String, SfSyncVo> sfSyncVoMap) {
        return CompositeRequest.builder()
                .url(String.format(GET_CO_APPLICANT.getUrl(), sfApiVersion, paramReferenceId))
                .method(GET_CO_APPLICANT.getMethod())
                .referenceId(String.format(GET_CO_APPLICANT.getReferenceId(), referenceId))
                .build();
    }

    private CompositeRequest buildGetGuarantorRequest(
            String paramReferenceId, String referenceId, String key, Map<String, SfSyncVo> sfSyncVoMap) {
        return CompositeRequest.builder()
                .url(String.format(GET_GUARANTOR.getUrl(), sfApiVersion, paramReferenceId))
                .method(GET_GUARANTOR.getMethod())
                .referenceId(String.format(GET_GUARANTOR.getReferenceId(), referenceId))
                .build();
    }

    private CompositeRequest buildGetAddressRequest(String addressType) {
        String modifiedCreateAddressRefId = getModifiedReferenceId(CREATE_ADDRESS, addressType);
        return CompositeRequest.builder()
                .url(String.format(GET_ADDRESS.getUrl(), sfApiVersion, modifiedCreateAddressRefId))
                .method(GET_ADDRESS.getMethod())
                .referenceId(getModifiedReferenceId(GET_ADDRESS, addressType))
                .build();
    }

    private CompositeRequest buildCoAppAndGuarantorGetAddressRequest(
            String addressType, String customerType, String number) {
        switch (customerType) {
            case CO_APPLICANT -> {
                String modifiedCreateAddressRefId = getCoAppAndGuarantorModifiedReferenceId(
                        CREATE_CO_APPLICANT_ADDRESS,
                        String.valueOf(extractNumberFromRefereenceId(number)),
                        addressType);

                return CompositeRequest.builder()
                        .url(String.format(GET_CO_APPLICANT_ADDRESS.getUrl(), sfApiVersion, modifiedCreateAddressRefId))
                        .method(GET_CO_APPLICANT_ADDRESS.getMethod())
                        .referenceId(String.format(
                                GET_CO_APPLICANT_ADDRESS.getReferenceId(),
                                extractNumberFromRefereenceId(number),
                                addressType))
                        .build();
            }
            case GUARANTOR -> {
                String modifiedCreateAddressRefId = getCoAppAndGuarantorModifiedReferenceId(
                        CREATE_GUARANTOR_ADDRESS, String.valueOf(extractNumberFromRefereenceId(number)), addressType);
                return CompositeRequest.builder()
                        .url(String.format(GET_GUARANTOR_ADDRESS.getUrl(), sfApiVersion, modifiedCreateAddressRefId))
                        .method(GET_GUARANTOR_ADDRESS.getMethod())
                        .referenceId(getCoAppAndGuarantorModifiedReferenceId(
                                GET_GUARANTOR_ADDRESS,
                                String.valueOf(extractNumberFromRefereenceId(number)),
                                addressType))
                        .build();
            }
            default -> throw new RuntimeException();
        }
    }

    private CompositeRequest buildGetAssetRequest() {
        return CompositeRequest.builder()
                .url(String.format(GET_ASSET.getUrl(), sfApiVersion, CREATE_ASSET.getReferenceId()))
                .method(GET_ASSET.getMethod())
                .referenceId(GET_ASSET.getReferenceId())
                .build();
    }

    private CompositeRequest buildGetDocumentCheckListRequest(
            DocumentChecklist document, String key, Map<String, SfSyncVo> sfSyncVoMap) {
        String referenceId = getModifiedReferenceId(CREATE_DOCUMENT_CHECKLIST, document.getDmsIdentifier());
        return CompositeRequest.builder()
                .url(String.format(GET_DOCUMENT_CHECKLIST.getUrl(), sfApiVersion, referenceId))
                .method(GET_DOCUMENT_CHECKLIST.getMethod())
                .referenceId(getModifiedReferenceId(GET_DOCUMENT_CHECKLIST, document.getDmsIdentifier()))
                .build();
    }

    private void buildAddressCompositeRequests(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            ApplicantMapping applicantMapping,
            String key,
            Map<String, SfSyncVo> sfSyncVoMap) {
        boolean isCurrentAddressPresent = isCurrentAddressPresent(addressDetails);
        Optional<List<AddressMapping>> addressMappings = getAddressMappingsByApplicantMapping(applicantMapping);

        if (addressMappings.isEmpty() || addressMappings.get().isEmpty()) {
            buildPostAddressCompositeRequest(
                    compositeRequest,
                    addressDetails,
                    isCurrentAddressPresent,
                    addressMatchStrengthResponse,
                    sfSyncVoMap,
                    key);
        } else {
            buildPatchAddressCompositeRequest(
                    compositeRequest,
                    addressDetails,
                    addressMappings,
                    isCurrentAddressPresent,
                    addressMatchStrengthResponse,
                    key,
                    sfSyncVoMap);
        }
    }

    private void buildCoAppAndGuarantorAddressCompositeRequests(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            ApplicantMapping applicantMapping,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType) {
        boolean isCurrentAddressPresent = isCurrentAddressPresent(addressDetails);
        Optional<List<AddressMapping>> addressMappings = getAddressMappingsByApplicantMapping(applicantMapping);

        if (addressMappings.isEmpty() || addressMappings.get().isEmpty()) {
            buildCoAppAndGuarantorPostAddressCompositeRequest(
                    compositeRequest,
                    addressDetails,
                    isCurrentAddressPresent,
                    addressMatchStrengthResponse,
                    sfSyncVo,
                    paramKey,
                    customerType);
        } else {
            buildCoAppAndGuarantorPatchAddressCompositeRequest(
                    compositeRequest,
                    addressDetails,
                    addressMappings,
                    isCurrentAddressPresent,
                    addressMatchStrengthResponse,
                    sfSyncVo,
                    paramKey,
                    customerType);
        }
    }

    private void buildCoAppAndGuarantorAddressCompositeRequests(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            ApplicantMapping applicantMapping,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType,
            String sfSyncVoKey) {
        boolean isCurrentAddressPresent = isCurrentAddressPresent(addressDetails);
        Optional<List<AddressMapping>> addressMappings = getAddressMappingsByApplicantMapping(applicantMapping);

        if (addressMappings.isEmpty() || addressMappings.get().isEmpty()) {
            buildCoAppAndGuarantorPostAddressCompositeRequest(
                    compositeRequest,
                    addressDetails,
                    isCurrentAddressPresent,
                    addressMatchStrengthResponse,
                    sfSyncVo,
                    paramKey,
                    customerType,
                    sfSyncVoKey);
        } else {
            buildCoAppAndGuarantorPatchAddressCompositeRequest(
                    compositeRequest,
                    addressDetails,
                    addressMappings,
                    isCurrentAddressPresent,
                    addressMatchStrengthResponse,
                    sfSyncVo,
                    paramKey,
                    customerType);
        }
    }

    private void buildPatchAddressCompositeRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            Optional<List<AddressMapping>> addressMappings,
            boolean isCurrentAddressPresent,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            String key,
            Map<String, SfSyncVo> sfSyncVoMap) {
        AddressMapping permanentAddressMapping = getAddressMappingIdByType(addressMappings, PERMANENT);
        AddressMapping currentAddressMapping = getAddressMappingIdByType(addressMappings, CURRENT);
        AddressMapping workAddressMapping = getAddressMappingIdByType(addressMappings, WORK);

        if (isNull(permanentAddressMapping) || isNull(currentAddressMapping))
            throw new EntityNotFoundException(ADDRESS_MAPPING_NOT_FOUND);

        boolean isActive = true;

        for (AddressResponse addressDetail : addressDetails) {
            boolean isWorkAddress = isWorkAddress(addressDetail);
            boolean isCommunicationAddress = !isWorkAddress
                    && (!isCurrentAddressPresent
                            || addressDetail.getAddressType().equalsIgnoreCase(CURRENT.getValue()));
            if (isWorkAddress) continue;
            if (!isCurrentAddressPresent) {
                addPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
                        compositeRequest,
                        addressMatchStrengthResponse,
                        sfSyncVoMap,
                        permanentAddressMapping,
                        currentAddressMapping,
                        isActive,
                        addressDetail,
                        isCommunicationAddress,
                        key);
            } else {
                if (isPermanentAddress(addressDetail)) {
                    addCompositeRequestsForAddress(
                            compositeRequest,
                            addressDetail,
                            isCommunicationAddress,
                            addressMatchStrengthResponse,
                            isActive,
                            permanentAddressMapping.getSfAddressId(),
                            key,
                            sfSyncVoMap);
                } else {
                    addCompositeRequestsForAddress(
                            compositeRequest,
                            addressDetail,
                            isCommunicationAddress,
                            addressMatchStrengthResponse,
                            isActive,
                            currentAddressMapping.getSfAddressId(),
                            key,
                            sfSyncVoMap);
                }
            }
        }

        addWorkAddressRequest(compositeRequest, addressDetails, sfSyncVoMap, workAddressMapping, isActive, key);
    }

    private void buildCoAppAndGuarantorPatchAddressCompositeRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            Optional<List<AddressMapping>> addressMappings,
            boolean isCurrentAddressPresent,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType) {
        AddressMapping permanentAddressMapping = getAddressMappingIdByType(addressMappings, PERMANENT);
        AddressMapping currentAddressMapping = getAddressMappingIdByType(addressMappings, CURRENT);
        AddressMapping workAddressMapping = getAddressMappingIdByType(addressMappings, WORK);

        if (isNull(permanentAddressMapping) || isNull(currentAddressMapping))
            throw new EntityNotFoundException(ADDRESS_MAPPING_NOT_FOUND);

        boolean isActive = true;

        for (AddressResponse addressDetail : addressDetails) {
            boolean isWorkAddress = isWorkAddress(addressDetail);
            boolean isCommunicationAddress = !isWorkAddress
                    && (!isCurrentAddressPresent
                            || addressDetail.getAddressType().equalsIgnoreCase(CURRENT.getValue()));
            if (isWorkAddress) continue;
            if (!isCurrentAddressPresent) {
                addCoAppAndGuarantorPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
                        compositeRequest,
                        addressMatchStrengthResponse,
                        sfSyncVo,
                        permanentAddressMapping,
                        currentAddressMapping,
                        isActive,
                        addressDetail,
                        isCommunicationAddress,
                        paramKey,
                        customerType);
            } else {
                if (isPermanentAddress(addressDetail)) {
                    addCoAppAndGuarantorCompositeRequestsForAddress(
                            compositeRequest,
                            addressDetail,
                            isCommunicationAddress,
                            addressMatchStrengthResponse,
                            isActive,
                            permanentAddressMapping.getSfAddressId(),
                            sfSyncVo,
                            paramKey,
                            customerType);
                } else {
                    addCoAppAndGuarantorCompositeRequestsForAddress(
                            compositeRequest,
                            addressDetail,
                            isCommunicationAddress,
                            addressMatchStrengthResponse,
                            isActive,
                            currentAddressMapping.getSfAddressId(),
                            sfSyncVo,
                            paramKey,
                            customerType);
                }
            }
        }

        addCoAppAndGuarantorWorkAddressRequest(
                compositeRequest, addressDetails, sfSyncVo, workAddressMapping, isActive, paramKey, customerType);
    }

    private void addWorkAddressRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            Map<String, SfSyncVo> sfSyncVoMap,
            AddressMapping workAddressMapping,
            boolean isActive,
            String key) {
        AddressResponse fosWorkAddress = getAddressResponseIdByType(addressDetails, WORK);
        if (nonNull(fosWorkAddress)) {
            if (isNull(workAddressMapping)) {
                addCompositeRequestsForAddress(
                        compositeRequest, fosWorkAddress, false, null, isActive, null, key, sfSyncVoMap);
            } else {
                addCompositeRequestsForAddress(
                        compositeRequest,
                        fosWorkAddress,
                        false,
                        null,
                        isActive,
                        workAddressMapping.getSfAddressId(),
                        key,
                        sfSyncVoMap);
            }
        } else if (nonNull(workAddressMapping)) {
            addCompositeRequestsForAddress(
                    compositeRequest,
                    AddressResponse.builder().build(),
                    false,
                    null,
                    !isActive,
                    workAddressMapping.getSfAddressId(),
                    key,
                    sfSyncVoMap);
        }
    }

    private void addCoAppAndGuarantorWorkAddressRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            Map<String, SfSyncVo> sfSyncVo,
            AddressMapping workAddressMapping,
            boolean isActive,
            String paramKey,
            String customerType) {
        AddressResponse fosWorkAddress = getAddressResponseIdByType(addressDetails, WORK);
        if (nonNull(fosWorkAddress)) {
            if (isNull(workAddressMapping)) {
                addCoAppAndGuarantorCompositeRequestsForAddress(
                        compositeRequest,
                        fosWorkAddress,
                        false,
                        null,
                        isActive,
                        null,
                        sfSyncVo,
                        paramKey,
                        customerType);
            } else {
                addCoAppAndGuarantorCompositeRequestsForAddress(
                        compositeRequest,
                        fosWorkAddress,
                        false,
                        null,
                        isActive,
                        workAddressMapping.getSfAddressId(),
                        sfSyncVo,
                        paramKey,
                        customerType);
            }
        } else if (nonNull(workAddressMapping)) {
            addCoAppAndGuarantorCompositeRequestsForAddress(
                    compositeRequest,
                    AddressResponse.builder().build(),
                    false,
                    null,
                    !isActive,
                    workAddressMapping.getSfAddressId(),
                    sfSyncVo,
                    paramKey,
                    customerType);
        }
    }

    private void addCoAppAndGuarantorWorkAddressRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            Map<String, SfSyncVo> sfSyncVo,
            AddressMapping workAddressMapping,
            boolean isActive,
            String paramKey,
            String customerType,
            String sfSyncVoKey) {
        AddressResponse fosWorkAddress = getAddressResponseIdByType(addressDetails, WORK);
        if (nonNull(fosWorkAddress)) {
            if (isNull(workAddressMapping)) {
                addCoAppAndGuarantorCompositeRequestsForAddress(
                        compositeRequest,
                        fosWorkAddress,
                        false,
                        null,
                        isActive,
                        null,
                        sfSyncVo,
                        paramKey,
                        customerType,
                        sfSyncVoKey);
            } else {
                addCoAppAndGuarantorCompositeRequestsForAddress(
                        compositeRequest,
                        fosWorkAddress,
                        false,
                        null,
                        isActive,
                        workAddressMapping.getSfAddressId(),
                        sfSyncVo,
                        paramKey,
                        customerType,
                        sfSyncVoKey);
            }
        } else if (nonNull(workAddressMapping)) {
            addCoAppAndGuarantorCompositeRequestsForAddress(
                    compositeRequest,
                    AddressResponse.builder().build(),
                    false,
                    null,
                    !isActive,
                    workAddressMapping.getSfAddressId(),
                    sfSyncVo,
                    paramKey,
                    customerType,
                    sfSyncVoKey);
        }
    }

    private void addPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
            List<CompositeRequest> compositeRequest,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVoMap,
            AddressMapping permanentAddressMapping,
            AddressMapping currentAddressMapping,
            boolean isActive,
            AddressResponse addressDetail,
            boolean isCommunicationAddress,
            String key) {
        addCompositeRequestsForAddress(
                compositeRequest,
                addressDetail,
                isCommunicationAddress,
                addressMatchStrengthResponse,
                isActive,
                (nonNull(permanentAddressMapping)) ? permanentAddressMapping.getSfAddressId() : null,
                key,
                sfSyncVoMap);

        AddressResponse currentAddress = new AddressResponse(addressDetail);
        currentAddress.setAddressType(CURRENT.getValue());
        addCompositeRequestsForAddress(
                compositeRequest,
                currentAddress,
                isCommunicationAddress,
                addressMatchStrengthResponse,
                isActive,
                (nonNull(currentAddressMapping)) ? currentAddressMapping.getSfAddressId() : null,
                key,
                sfSyncVoMap);
    }

    private void addCoAppAndGuarantorPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
            List<CompositeRequest> compositeRequest,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVo,
            AddressMapping permanentAddressMapping,
            AddressMapping currentAddressMapping,
            boolean isActive,
            AddressResponse addressDetail,
            boolean isCommunicationAddress,
            String paramKey,
            String customerType) {
        addCoAppAndGuarantorCompositeRequestsForAddress(
                compositeRequest,
                addressDetail,
                isCommunicationAddress,
                addressMatchStrengthResponse,
                isActive,
                (nonNull(permanentAddressMapping)) ? permanentAddressMapping.getSfAddressId() : null,
                sfSyncVo,
                paramKey,
                customerType);

        AddressResponse currentAddress = new AddressResponse(addressDetail);
        currentAddress.setAddressType(CURRENT.getValue());
        addCoAppAndGuarantorCompositeRequestsForAddress(
                compositeRequest,
                currentAddress,
                isCommunicationAddress,
                addressMatchStrengthResponse,
                isActive,
                (nonNull(currentAddressMapping)) ? currentAddressMapping.getSfAddressId() : null,
                sfSyncVo,
                paramKey,
                customerType);
    }

    private void addCoAppAndGuarantorPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
            List<CompositeRequest> compositeRequest,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVo,
            AddressMapping permanentAddressMapping,
            AddressMapping currentAddressMapping,
            boolean isActive,
            AddressResponse addressDetail,
            boolean isCommunicationAddress,
            String paramKey,
            String customerType,
            String sfSyncVoKey) {
        addCoAppAndGuarantorCompositeRequestsForAddress(
                compositeRequest,
                addressDetail,
                isCommunicationAddress,
                addressMatchStrengthResponse,
                isActive,
                (nonNull(permanentAddressMapping)) ? permanentAddressMapping.getSfAddressId() : null,
                sfSyncVo,
                paramKey,
                customerType,
                sfSyncVoKey);

        AddressResponse currentAddress = new AddressResponse(addressDetail);
        currentAddress.setAddressType(CURRENT.getValue());
        addCoAppAndGuarantorCompositeRequestsForAddress(
                compositeRequest,
                currentAddress,
                isCommunicationAddress,
                addressMatchStrengthResponse,
                isActive,
                (nonNull(currentAddressMapping)) ? currentAddressMapping.getSfAddressId() : null,
                sfSyncVo,
                paramKey,
                customerType,
                sfSyncVoKey);
    }

    private void buildPostAddressCompositeRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            boolean isCurrentAddressPresent,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVoMap,
            String key) {
        boolean isActive = true;
        for (AddressResponse addressDetail : addressDetails) {
            boolean isWorkAddress = isWorkAddress(addressDetail);
            boolean isCommunicationAddress = !isWorkAddress
                    && (!isCurrentAddressPresent
                            || addressDetail.getAddressType().equalsIgnoreCase(CURRENT.getValue()));

            if (isWorkAddress) continue;
            if (!isCurrentAddressPresent) {
                addPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
                        compositeRequest,
                        addressMatchStrengthResponse,
                        sfSyncVoMap,
                        null,
                        null,
                        isActive,
                        addressDetail,
                        isCommunicationAddress,
                        key);
            } else {
                addCompositeRequestsForAddress(
                        compositeRequest,
                        addressDetail,
                        isCommunicationAddress,
                        addressMatchStrengthResponse,
                        isActive,
                        null,
                        key,
                        sfSyncVoMap);
            }
        }

        addWorkAddressRequest(compositeRequest, addressDetails, sfSyncVoMap, null, isActive, key);
    }

    private void buildCoAppAndGuarantorPostAddressCompositeRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            boolean isCurrentAddressPresent,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType) {
        boolean isActive = true;
        for (AddressResponse addressDetail : addressDetails) {
            boolean isWorkAddress = isWorkAddress(addressDetail);
            boolean isCommunicationAddress = !isWorkAddress
                    && (!isCurrentAddressPresent
                            || addressDetail.getAddressType().equalsIgnoreCase(CURRENT.getValue()));

            if (isWorkAddress) continue;
            if (!isCurrentAddressPresent) {
                addCoAppAndGuarantorPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
                        compositeRequest,
                        addressMatchStrengthResponse,
                        sfSyncVo,
                        null,
                        null,
                        isActive,
                        addressDetail,
                        isCommunicationAddress,
                        paramKey,
                        customerType);
            } else {
                addCoAppAndGuarantorCompositeRequestsForAddress(
                        compositeRequest,
                        addressDetail,
                        isCommunicationAddress,
                        addressMatchStrengthResponse,
                        isActive,
                        null,
                        sfSyncVo,
                        paramKey,
                        customerType);
            }
        }

        addCoAppAndGuarantorWorkAddressRequest(
                compositeRequest, addressDetails, sfSyncVo, null, isActive, paramKey, customerType);
    }

    private void buildCoAppAndGuarantorPostAddressCompositeRequest(
            List<CompositeRequest> compositeRequest,
            List<AddressResponse> addressDetails,
            boolean isCurrentAddressPresent,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType,
            String sfSyncVoKey) {
        boolean isActive = true;
        for (AddressResponse addressDetail : addressDetails) {
            boolean isWorkAddress = isWorkAddress(addressDetail);
            boolean isCommunicationAddress = !isWorkAddress
                    && (!isCurrentAddressPresent
                            || addressDetail.getAddressType().equalsIgnoreCase(CURRENT.getValue()));

            if (isWorkAddress) continue;
            if (!isCurrentAddressPresent) {
                addCoAppAndGuarantorPermanentAndCurrentAddressRequestWhenCurrentAddressNotPresent(
                        compositeRequest,
                        addressMatchStrengthResponse,
                        sfSyncVo,
                        null,
                        null,
                        isActive,
                        addressDetail,
                        isCommunicationAddress,
                        paramKey,
                        customerType,
                        sfSyncVoKey);
            } else {
                addCoAppAndGuarantorCompositeRequestsForAddress(
                        compositeRequest,
                        addressDetail,
                        isCommunicationAddress,
                        addressMatchStrengthResponse,
                        isActive,
                        null,
                        sfSyncVo,
                        paramKey,
                        customerType,
                        sfSyncVoKey);
            }
        }

        addCoAppAndGuarantorWorkAddressRequest(
                compositeRequest, addressDetails, sfSyncVo, null, isActive, paramKey, customerType, sfSyncVoKey);
    }

    private Optional<List<AddressMapping>> getAddressMappingsByApplicantMapping(ApplicantMapping applicantMapping) {
        if (isNull(applicantMapping)) return Optional.empty();
        return addressMappingRepository.findByApplicantMappingApplicantId(applicantMapping.getApplicantId());
    }

    private void addCompositeRequestsForAddress(
            List<CompositeRequest> compositeRequest,
            AddressResponse addressDetail,
            boolean isCommunicationAddress,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            boolean isActive,
            String sfAddressId,
            String key,
            Map<String, SfSyncVo> sfSyncVoMap) {
        compositeRequest.add(buildAddressRequest(
                mapToAddress(addressDetail, isCommunicationAddress, addressMatchStrengthResponse, isActive),
                sfAddressId));
        if (isActive) {
            compositeRequest.add(buildGetAddressRequest(addressDetail.getAddressType()));

            String referenceId = getModifiedReferenceId(GET_ADDRESS, addressDetail.getAddressType());
            sfSyncVoMap.get(key).getRefAddressIdMappingTracker().put(referenceId, addressDetail.getAddressId());
        }
    }

    private void addCoAppAndGuarantorCompositeRequestsForAddress(
            List<CompositeRequest> compositeRequest,
            AddressResponse addressDetail,
            boolean isCommunicationAddress,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            boolean isActive,
            String sfAddressId,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType,
            String sfSyncVoKey) {
        CompositeRequest compositeRequest1 = buildCoAppAndGuarantorAddressRequest(
                mapToCoAppAndGuarantorAddress(
                        addressDetail, isCommunicationAddress, addressMatchStrengthResponse, isActive, paramKey),
                sfAddressId,
                customerType,
                paramKey,
                sfSyncVo);
        compositeRequest.add(compositeRequest1);
        if (isActive) {
            compositeRequest.add(
                    buildCoAppAndGuarantorGetAddressRequest(addressDetail.getAddressType(), customerType, paramKey));
            String referenceId = "";
            if (customerType.equalsIgnoreCase(CO_APPLICANT))
                referenceId = getCoAppAndGuarantorModifiedReferenceId(
                        GET_CO_APPLICANT_ADDRESS,
                        String.valueOf(extractNumberFromRefereenceId(paramKey)),
                        addressDetail.getAddressType());
            else if (customerType.equalsIgnoreCase(GUARANTOR))
                referenceId = getCoAppAndGuarantorModifiedReferenceId(
                        GET_GUARANTOR_ADDRESS,
                        String.valueOf(extractNumberFromRefereenceId(paramKey)),
                        addressDetail.getAddressType());

            sfSyncVo.get(sfSyncVoKey).getRefAddressIdMappingTracker().put(referenceId, addressDetail.getAddressId());
        }
    }

    private void addCoAppAndGuarantorCompositeRequestsForAddress(
            List<CompositeRequest> compositeRequest,
            AddressResponse addressDetail,
            boolean isCommunicationAddress,
            AddressMatchStrengthResponse addressMatchStrengthResponse,
            boolean isActive,
            String sfAddressId,
            Map<String, SfSyncVo> sfSyncVo,
            String paramKey,
            String customerType) {
        CompositeRequest compositeRequest1 = buildCoAppAndGuarantorAddressRequest(
                mapToCoAppAndGuarantorAddress(
                        addressDetail, isCommunicationAddress, addressMatchStrengthResponse, isActive, paramKey),
                sfAddressId,
                customerType,
                paramKey,
                sfSyncVo);
        compositeRequest.add(compositeRequest1);
        if (isActive) {
            compositeRequest.add(
                    buildCoAppAndGuarantorGetAddressRequest(addressDetail.getAddressType(), customerType, paramKey));

            String referenceId = getModifiedReferenceId(GET_ADDRESS, addressDetail.getAddressType());
            sfSyncVo.values().stream().findFirst().ifPresent(t -> t.getRefAddressIdMappingTracker()
                    .put(referenceId, addressDetail.getAddressId()));
        }
    }

    private AddressResponse getAddressResponseIdByType(
            List<AddressResponse> addressResponseList, AddressType addressType) {
        return addressResponseList.stream()
                .filter(addressResponse -> addressResponse.getAddressType().equalsIgnoreCase(addressType.getValue()))
                .findFirst()
                .orElse(null);
    }

    private static boolean isPermanentAddress(AddressResponse addressDetail) {
        return addressDetail.getAddressType().equalsIgnoreCase(PERMANENT.getValue());
    }

    private static boolean isWorkAddress(AddressResponse addressDetail) {
        return addressDetail.getAddressType().equalsIgnoreCase(WORK.getValue());
    }

    private static boolean isCurrentAddressPresent(List<AddressResponse> addressDetails) {
        return addressDetails.stream()
                .anyMatch(addressDetail -> addressDetail.getAddressType().equalsIgnoreCase(CURRENT.getValue()));
    }

    private AddressMapping getAddressMappingIdByType(
            Optional<List<AddressMapping>> addressMappings, AddressType addressType) {
        if (addressMappings.isEmpty()) return null;
        return addressMappings.get().stream()
                .filter(mapping -> mapping.getAddressType() == addressType)
                .findFirst()
                .orElse(null);
    }

    private CompositeRequest buildAddressRequest(Address address, String addressId) {
        String sfAddressId = Objects.isNull(addressId) ? null : addressId;
        String modifiedRefId = getModifiedReferenceId(CREATE_ADDRESS, address.getAddressType());
        boolean isSyncAlreadyDone = nonNull(addressId);
        return CompositeRequest.builder()
                .url(getSyncResourceUrl(isSyncAlreadyDone, CREATE_ADDRESS, UPDATE_ADDRESS, sfAddressId, sfApiVersion))
                .body(address)
                .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_ADDRESS, UPDATE_ADDRESS))
                .referenceId(modifiedRefId)
                .build();
    }

    private CompositeRequest buildCoAppAndGuarantorAddressRequest(
            Address address, String addressId, String customerType, String paramKey, Map<String, SfSyncVo> sfSyncVo) {
        String sfAddressId = isNull(addressId) ? null : addressId;
        switch (customerType) {
            case CO_APPLICANT -> {
                String modifiedRefId = getCoAppAndGuarantorModifiedReferenceId(
                        CREATE_CO_APPLICANT_ADDRESS,
                        extractNumberFromRefereenceId(paramKey).toString(),
                        address.getAddressType());
                boolean isSyncAlreadyDone = nonNull(addressId);
                return CompositeRequest.builder()
                        .url(getCoAppAndGuarantorSyncResourceUrl(
                                isSyncAlreadyDone,
                                CREATE_CO_APPLICANT_ADDRESS,
                                UPDATE_CO_APPLICANT_ADDRESS,
                                sfAddressId,
                                sfApiVersion,
                                extractNumberFromRefereenceId(paramKey)))
                        .body(address)
                        .method(getSyncResourceMethod(
                                isSyncAlreadyDone, CREATE_CO_APPLICANT_ADDRESS, UPDATE_CO_APPLICANT_ADDRESS))
                        .referenceId(modifiedRefId)
                        .build();
            }
            case GUARANTOR -> {
                String modifiedRefId = getCoAppAndGuarantorModifiedReferenceId(
                        CREATE_GUARANTOR_ADDRESS,
                        extractNumberFromRefereenceId(paramKey).toString(),
                        address.getAddressType());
                boolean isSyncAlreadyDone = nonNull(addressId);
                return CompositeRequest.builder()
                        .url(getCoAppAndGuarantorSyncResourceUrl(
                                isSyncAlreadyDone,
                                CREATE_GUARANTOR_ADDRESS,
                                UPDATE_GUARANTOR_ADDRESS,
                                sfAddressId,
                                sfApiVersion,
                                extractNumberFromRefereenceId(paramKey)))
                        .body(address)
                        .method(getSyncResourceMethod(
                                isSyncAlreadyDone, CREATE_GUARANTOR_ADDRESS, UPDATE_GUARANTOR_ADDRESS))
                        .referenceId(modifiedRefId)
                        .build();
            }
            default -> throw new IllegalStateException(MESSAGE + customerType);
        }
    }

    private CompositeRequest buildAddOnProductRequest(AddOnProduct addOnProduct, int count) {
        return CompositeRequest.builder()
                .url(String.format(CREATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion))
                .body(addOnProduct)
                .method(CREATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(CREATE_ADD_ON_PRODUCTS.getReferenceId(), count))
                .build();
    }

    private CompositeRequest buildAddOnProductUpdateRequest(
            AddOnProduct addOnProduct, String sfProductId, String count) {
        return CompositeRequest.builder()
                .url(String.format(UPDATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion, sfProductId))
                .body(addOnProduct)
                .method(UPDATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(UPDATE_ADD_ON_PRODUCTS.getReferenceId(), count))
                .build();
    }

    private CompositeRequest buildAddOnProductDeleteRequest(AddOnProduct addOnProduct, String sfProductId, int count) {
        return CompositeRequest.builder()
                .url(String.format(UPDATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion, sfProductId))
                .body(addOnProduct)
                .method(UPDATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(UPDATE_ADD_ON_PRODUCTS.getReferenceId(), count))
                .build();
    }

    private String getModifiedReferenceId(SfSyncResource sfSyncResource, String addition) {
        return String.format(sfSyncResource.getReferenceId(), addition);
    }

    private String getCoAppAndGuarantorModifiedReferenceId(
            SfSyncResource sfSyncResource, String number, String addition) {
        return String.format(sfSyncResource.getReferenceId(), extractNumberFromRefereenceId(number), addition);
    }

    private void parseResponseId(CompositeResponse<SuccessBody> compositeResponse, SfSyncVo sfSyncVo) {
        SuccessBody body = objectMapper.convertValue(compositeResponse.getBody(), SuccessBody.class);
        Map<String, String> attributes = body.getAttributes();

        if (nonNull(attributes) && !attributes.isEmpty()) {
            switch (attributes.get(REQUEST_TYPE_KEYWORD)) {
                case APPLICANT_REQUEST_TYPE -> {
                    log.info("Applicant id: {}", body.getApplicantId());
                    sfSyncVo.setSfApplicantId(body.getApplicantId());
                }
                case DOC_CHECKLIST_REQUEST_TYPE -> {
                    log.info("Doc checklist id: {}", body.getChecklistId());
                    sfSyncVo.getDocDmsIdMappings().forEach(docDmsIdMapping -> {
                        if (nonNull(body.getDmsIdentifier())
                                && body.getDmsIdentifier().equals(docDmsIdMapping.getDmsId())) {
                            sfSyncVo.getDocIdSfChecklistIdMapping()
                                    .put(docDmsIdMapping.getDocId(), body.getChecklistId());
                        }
                    });
                }
                case ADDRESS_REQUEST_TYPE -> {
                    log.info("Address id: {}", body.getAddressId());
                    sfSyncVo.getAddressMappingVoList().add(buildAddressMappingVo(compositeResponse, body, sfSyncVo));
                }
                case ASSET_REQUEST_TYPE -> {
                    log.info("Asset id: {}", body.getAssetId());
                    sfSyncVo.setSfAssetId(body.getAssetId());
                }
                case BANKING_REQUEST_TYPE -> {
                    log.info("Banking id: {}", body.getBankingId());
                    sfSyncVo.setSfBankDetailsId(body.getBankingId());
                }
                case LOAN_CHARGE_TYPE -> {
                    log.info("Charge id: {}", body.getChargeId());
                    sfSyncVo.getFosAndSfChargeIdMapping().put(body.getFosChargeId(), body.getChargeId());
                }
                case PAYOUT_TYPE -> {
                    log.info("Payout id: {}", body.getPayoutId());
                    sfSyncVo.setSfPayoutId(body.getPayoutId());
                }
                case ADD_ON_PRODUCT_TYPE -> {
                    log.info("Add On Products id is : {}", body.getAddOnProductId());
                    if (MAS.equals(body.getName())) {
                        sfSyncVo.getAddOnProductMappingVo()
                                .add(AddOnProductMappingVo.builder()
                                        .sfProductId(body.getAddOnProductId())
                                        .offerType(OfferType.MAS)
                                        .isActive(body.getIsActive())
                                        .build());
                    } else if (MLS.equals(body.getName())) {
                        sfSyncVo.getAddOnProductMappingVo()
                                .add(AddOnProductMappingVo.builder()
                                        .sfProductId(body.getAddOnProductId())
                                        .offerType(OfferType.MLS)
                                        .isActive(body.getIsActive())
                                        .build());
                    } else {
                        sfSyncVo.getAddOnProductMappingVo()
                                .add(AddOnProductMappingVo.builder()
                                        .sfProductId(body.getAddOnProductId())
                                        .offerType(OfferType.OTHER)
                                        .productCode(body.getAddOnProductCode())
                                        .build());
                    }
                }
                case BUREAU_RESPONSE_TYPE -> {
                    log.info("Bureau response id is: {}", body.getSfdcId());
                    sfSyncVo.setSfBureauResponseId(body.getChargeId());
                }
                case INSURED_DETAIL_TYPE -> {
                    log.info("Insured detail id is: {}", body.getInsuredId());
                    if (sfSyncVo.getInsuredDetailMappings().containsKey(compositeResponse.getReferenceId())) {
                        setSfInsuredId(compositeResponse, sfSyncVo, body);
                    } else {
                        addInsuredDetailMappingVoEntry(compositeResponse, sfSyncVo, body);
                    }
                }
                case APPLICANT_FINANCIALS_TYPE -> {
                    if (Boolean.FALSE.equals(body.getIsActive())) {
                        sfSyncVo.getInactiveApplicantsFinancialIds().add(body.getApplicantFinancialId());
                    }
                }
                case VIABILITY_TEMPLATE_TYPE -> {
                    if (Boolean.FALSE.equals(body.getIsActive())) {
                        sfSyncVo.getInactiveViabilityTemplateIds().add(body.getViabilityTemplateId());
                    }
                }
                default -> throw new ExternalServiceResponseException(INVALID_RESPONSE_RECEIVED_WHILE_QUE_SYNC);
            }
        }
    }

    private void parseCoAppAndGuarantorResponseId(
            CompositeResponse<SuccessBody> compositeResponse, Map<String, SfSyncVo> sfSyncVo) {
        SuccessBody body = objectMapper.convertValue(compositeResponse.getBody(), SuccessBody.class);
        Map<String, String> attributes = body.getAttributes();

        if (isAttrPresent(attributes)) {
            for (SfSyncVo sfSyncVoValue : sfSyncVo.values()) {
                handleResponseByType(attributes, body, sfSyncVoValue, compositeResponse);
            }
        }
    }

    private void handleResponseByType(
            Map<String, String> attributes,
            SuccessBody body,
            SfSyncVo sfSyncVoValue,
            CompositeResponse<SuccessBody> compositeResponse) {
        switch (attributes.get(REQUEST_TYPE_KEYWORD)) {
            case APPLICANT_REQUEST_TYPE -> handleApplicantRequestType(body, sfSyncVoValue);
            case DOC_CHECKLIST_REQUEST_TYPE -> handleDocChecklistRequestType(body, sfSyncVoValue);
            case ADDRESS_REQUEST_TYPE -> handleAddressRequestType(body, sfSyncVoValue, compositeResponse);
            case ASSET_REQUEST_TYPE -> handleAssetRequestType(body, sfSyncVoValue);
            case BANKING_REQUEST_TYPE -> handleBankingRequestType(body, sfSyncVoValue);
            case LOAN_CHARGE_TYPE -> handleLoanChargeType(body, sfSyncVoValue);
            case PAYOUT_TYPE -> handlePayoutType(body, sfSyncVoValue);
            case ADD_ON_PRODUCT_TYPE -> handleAddOnProductType(body, sfSyncVoValue);
            case BUREAU_RESPONSE_TYPE -> handleBureauResponseType(body, sfSyncVoValue);
            case INSURED_DETAIL_TYPE -> handleInsuredDetailType(body, sfSyncVoValue, compositeResponse);
            case APPLICANT_FINANCIALS_TYPE -> handleApplicantFinancialsType(body, sfSyncVoValue);
            case VIABILITY_TEMPLATE_TYPE -> handleViabilityTemplateType(body, sfSyncVoValue);
            default -> throw new ExternalServiceResponseException(INVALID_RESPONSE_RECEIVED_WHILE_QUE_SYNC);
        }
    }

    private void handleApplicantRequestType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Applicant id: {}", body.getApplicantId());
        if (sfSyncVoValue.getApplicantId().toString().equals(body.getCustomerId())) {
            sfSyncVoValue.setSfApplicantId(body.getApplicantId());
        }
    }

    private void handleDocChecklistRequestType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Doc checklist id: {}", body.getChecklistId());
        if (sfSyncVoValue.getApplicantId().toString().equals(body.getCustomerId())) {
            for (Document document : sfSyncVoValue.getDocDmsIdMappings()) {
                if (nonNull(body.getDmsIdentifier()) && body.getDmsIdentifier().equals(document.getDmsId())) {
                    sfSyncVoValue.getDocIdSfChecklistIdMapping().put(document.getDocId(), body.getChecklistId());
                }
            }
        }
    }

    private void handleAddressRequestType(
            SuccessBody body, SfSyncVo sfSyncVoValue, CompositeResponse<SuccessBody> compositeResponse) {
        log.info("Address id: {}", body.getAddressId());
        if (sfSyncVoValue.getApplicantId().toString().equals(body.getCustomerId())) {
            sfSyncVoValue.getAddressMappingVoList().add(buildAddressMappingVo(compositeResponse, body, sfSyncVoValue));
        }
    }

    private void handleAssetRequestType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Asset id type : {}", body.getAssetId());
        sfSyncVoValue.setSfAssetId(body.getAssetId());
    }

    private void handleBankingRequestType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Banking id type: {}", body.getBankingId());
        sfSyncVoValue.setSfBankDetailsId(body.getBankingId());
    }

    private void handleLoanChargeType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Charge id type : {}", body.getChargeId());
        sfSyncVoValue.getFosAndSfChargeIdMapping().put(body.getFosChargeId(), body.getChargeId());
    }

    private void handlePayoutType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Payout id type : {}", body.getPayoutId());
        sfSyncVoValue.setSfPayoutId(body.getPayoutId());
    }

    private void handleAddOnProductType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Add On Products type id is : {}", body.getAddOnProductId());
        AddOnProductMappingVo addOnProductMappingVo = AddOnProductMappingVo.builder()
                .sfProductId(body.getAddOnProductId())
                .isActive(body.getIsActive())
                .build();
        if (MAS.equals(body.getName())) {
            addOnProductMappingVo.setOfferType(OfferType.MAS);
        } else if (MLS.equals(body.getName())) {
            addOnProductMappingVo.setOfferType(OfferType.MLS);
        } else {
            addOnProductMappingVo.setOfferType(OfferType.OTHER);
            addOnProductMappingVo.setProductCode(body.getAddOnProductCode());
        }
        sfSyncVoValue.getAddOnProductMappingVo().add(addOnProductMappingVo);
    }

    private void handleBureauResponseType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        log.info("Bureau response type id is: {}", body.getSfdcId());
        if (sfSyncVoValue.getApplicantId().toString().equals(body.getCustomerId())) {
            sfSyncVoValue.setSfBureauResponseId(body.getChargeId());
        }
    }

    private void handleInsuredDetailType(
            SuccessBody body, SfSyncVo sfSyncVoValue, CompositeResponse<SuccessBody> compositeResponse) {
        log.info("Insured detail type id is: {}", body.getInsuredId());
        if (sfSyncVoValue.getInsuredDetailMappings().containsKey(compositeResponse.getReferenceId())) {
            setSfInsuredId(compositeResponse, sfSyncVoValue, body);
        } else {
            addInsuredDetailMappingVoEntry(compositeResponse, sfSyncVoValue, body);
        }
    }

    private void handleApplicantFinancialsType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        if (Boolean.FALSE.equals(body.getIsActive())) {
            sfSyncVoValue.getInactiveApplicantsFinancialIds().add(body.getApplicantFinancialId());
        }
    }

    private void handleViabilityTemplateType(SuccessBody body, SfSyncVo sfSyncVoValue) {
        if (Boolean.FALSE.equals(body.getIsActive())) {
            sfSyncVoValue.getInactiveViabilityTemplateIds().add(body.getViabilityTemplateId());
        }
    }

    private static boolean isAttrPresent(Map<String, String> attributes) {
        return nonNull(attributes) && !attributes.isEmpty();
    }

    private void addInsuredDetailMappingVoEntry(
            CompositeResponse<SuccessBody> compositeResponse, SfSyncVo sfSyncVo, SuccessBody body) {
        InsuredDetailMappingVo insuredDetailMappingVo = InsuredDetailMappingVo.builder()
                .sfInsuredIdC(body.getInsuredId())
                .isActive(body.getIsActive())
                .build();
        sfSyncVo.getInsuredDetailMappings().put(compositeResponse.getReferenceId(), insuredDetailMappingVo);
    }

    private void setSfInsuredId(CompositeResponse<SuccessBody> compositeResponse, SfSyncVo sfSyncVo, SuccessBody body) {
        InsuredDetailMappingVo insuredDetailMappingVo =
                sfSyncVo.getInsuredDetailMappings().get(compositeResponse.getReferenceId());
        insuredDetailMappingVo.setSfInsuredIdC(body.getInsuredId());
        insuredDetailMappingVo.setIsActive(body.getIsActive());
    }

    private AddressMappingVo buildAddressMappingVo(
            CompositeResponse<SuccessBody> compositeResponse, SuccessBody body, SfSyncVo sfSyncVo) {
        String referenceId = compositeResponse.getReferenceId();
        UUID fosAddressId = sfSyncVo.getRefAddressIdMappingTracker().get(referenceId);
        return AddressMappingVo.builder()
                .sfAddressId(body.getAddressId())
                .fosAddressId(fosAddressId)
                .addressType(AddressType.getByValue(body.getAddressType()))
                .build();
    }

    private SfSyncResponse parseSfResponse(Graph graph, SfSyncVo sfSyncVo, SfSyncStage stage) {
        return graph.isSuccessful() ? buildSuccessResponse(graph, sfSyncVo, stage) : buildErrorResponse(graph);
    }

    private SfSyncResponse parseCoAppAndGuarantorAndApplicantSfResponse(
            Graph graph, Map<String, SfSyncVo> sfSyncVo, SfSyncStage stage) {
        return graph.isSuccessful()
                ? buildCoAppAndGuarantorSuccessResponse(graph, sfSyncVo, stage)
                : buildErrorResponse(graph);
    }

    private SfSyncResponse buildSuccessResponse(Graph graph, SfSyncVo sfSyncVo, SfSyncStage stage) {
        log.info("SalesForce data sync has been completed successfully for stage: {}.", stage);
        SfSyncResponse sfSyncResponse = new SfSyncResponse();
        GraphResponse<SuccessBody> graphResponse = graph.getGraphResponse();
        List<CompositeResponse<SuccessBody>> compositeResponses = graphResponse.getCompositeResponse();

        compositeResponses.forEach(compositeResponse -> {
            parseResponseId(compositeResponse, sfSyncVo);
            sfSyncResponse.setIsSuccessful(TRUE);
        });
        saveToDb(sfSyncVo, stage);
        return sfSyncResponse;
    }

    private SfSyncResponse buildCoAppAndGuarantorSuccessResponse(
            Graph graph, Map<String, SfSyncVo> sfSyncVo, SfSyncStage stage) {
        log.info("SalesForce data sync has been completed successfully for stage: {}.", stage);
        SfSyncResponse sfSyncResponse = new SfSyncResponse();
        GraphResponse<SuccessBody> graphResponse = graph.getGraphResponse();
        List<CompositeResponse<SuccessBody>> compositeResponses = graphResponse.getCompositeResponse();

        compositeResponses.forEach(compositeResponse -> parseCoAppAndGuarantorResponseId(compositeResponse, sfSyncVo));
        sfSyncVo.values().forEach(t -> saveToDb(t, stage));
        sfSyncResponse.setIsSuccessful(TRUE);
        return sfSyncResponse;
    }

    private ApplicantMapping getApplicantMappingByApplicationId(String applicationId) {
        return applicantMappingRepository
                .findByApplicationMappingApplicationId(applicationId)
                .orElseThrow(() -> new InvalidRequestException(APPLICANT_NOT_FOUND_FOR_GIVEN_APPLICATION_ID));
    }

    private ApplicantMapping getApplicantMappingByApplicationIdAndApplicantId(String applicationId, UUID applicantId) {
        return applicantMappingRepository
                .findByApplicationMappingApplicationIdAndApplicantId(applicationId, applicantId)
                .orElseThrow(() -> new InvalidRequestException(APPLICANT_NOT_FOUND_FOR_GIVEN_APPLICATION_ID));
    }

    private void saveToDb(SfSyncVo sfSyncVo, SfSyncStage stage) {
        if (stage.equals(UPTO_QDE1)) {
            saveQde1DataToDb(sfSyncVo);
        } else if (stage.equals(DDE)) {
            saveDdeDataToDb(sfSyncVo);
        } else if (stage.equals(ADD_ON_PRODUCTS)) {
            saveAddOnProducts(sfSyncVo);
        }
    }

    private void saveAddOnProducts(SfSyncVo sfSyncVo) {
        insuredDetailHelper.saveInsuredDetails(sfSyncVo);
        String applicationId = sfSyncVo.getApplicationId();
        ApplicationMapping applicationMapping = applicationMappingRepository
                .findByApplicationId(applicationId)
                .orElse(ApplicationMapping.builder()
                        .applicationId(applicationId)
                        .build());

        ApplicationMapping savedApplicationMapping = applicationMappingRepository.save(applicationMapping);

        // remove inactive product ids from the mapping table
        List<String> inactiveSfIds = sfSyncVo.getAddOnProductMappingVo().stream()
                .filter(m -> !m.getIsActive())
                .map(AddOnProductMappingVo::getSfProductId)
                .toList();
        if (!inactiveSfIds.isEmpty()) {
            addOnProductMappingRepository.flush(); // it is recommended to flush before calling the below method
            addOnProductMappingRepository.deleteAllByIdInBatch(inactiveSfIds);
        }

        // save the new sf product ids in the mapping table
        List<AddOnProductMapping> addOnProductMappings = sfSyncVo.getAddOnProductMappingVo().stream()
                .filter(AddOnProductMappingVo::getIsActive)
                .map(m -> AddOnProductMapping.builder()
                        .offerId(sfSyncVo.getOfferId())
                        .offerType(m.getOfferType())
                        .sfAddOnProductId(m.getSfProductId())
                        .applicationMapping(savedApplicationMapping)
                        .isActive(Boolean.TRUE)
                        .build())
                .toList();

        addOnProductMappingRepository.saveAll(addOnProductMappings);
    }

    private void saveQde1DataToDb(SfSyncVo sfSyncVo) {
        if (sfSyncVo.isQdeDeactivation()) {
            applicantFinancialsRequestHandler.saveQdeOneSyncInactiveDetails(
                    sfSyncVo.getInactiveApplicantsFinancialIds());
            incomeAssessmentRequestHandler.saveQdeOneSyncInactiveDetails(sfSyncVo.getInactiveViabilityTemplateIds());
            return;
        }

        ApplicationMapping applicationMapping = saveApplicationMapping(sfSyncVo);
        saveOtherMappings(applicationMapping, sfSyncVo);
        saveDocUpload(sfSyncVo);
    }

    private void saveDocUpload(SfSyncVo sfSyncVo) {
        sfSyncVo.getDocIdSfChecklistIdMapping().forEach((docId, sfChecklistId) -> {
            UUID docServiceUuid = UUID.fromString(docId);
            ChecklistIdMapping checklistIdMapping = checklistIdMappingRepository
                    .getFirstByDocServiceUuidOrderByCreatedAtDesc(docServiceUuid)
                    .orElse(ChecklistIdMapping.builder()
                            .docServiceUuid(docServiceUuid)
                            .sfDocChecklistId(sfChecklistId)
                            .build());
            try {
                checklistIdMappingRepository.save(checklistIdMapping);
            } catch (Exception ex) {
                log.error(
                        "failed to add checklist Id mapping. Doc service uuid: {} Sf doc checklist Id: {}",
                        checklistIdMapping.getDocServiceUuid(),
                        checklistIdMapping.getSfDocChecklistId());
                throw ex;
            }
        });
    }

    private void saveOtherMappings(ApplicationMapping applicationMapping, SfSyncVo sfSyncVo) {
        ApplicantMapping applicantMapping = applicantMappingRepository
                .findByApplicantId(sfSyncVo.getApplicantId())
                .orElse(ApplicantMapping.builder()
                        .applicantId(sfSyncVo.getApplicantId())
                        .sfApplicantId(sfSyncVo.getSfApplicantId())
                        .applicationMapping(applicationMapping)
                        .build());

        applicantMapping = applicantMappingRepository.save(applicantMapping);

        BureauResponseMapping bureauResponseMapping = BureauResponseMapping.builder()
                .sfBureauResponseId(sfSyncVo.getSfBureauResponseId())
                .applicationMapping(applicationMapping)
                .applicantId(sfSyncVo.getApplicantId())
                .build();

        bureauResponseMappingRepository.save(bureauResponseMapping);

        LoanAssetMapping loanAssetMapping = LoanAssetMapping.builder()
                .sfAssetId(sfSyncVo.getSfAssetId())
                .applicationMapping(applicationMapping)
                .build();

        loanAssetMappingRepository.save(loanAssetMapping);

        List<AddOnProductMapping> addOnProductMappings = new ArrayList<>();
        for (AddOnProductMappingVo addOnProductMappingVo : sfSyncVo.getAddOnProductMappingVo()) {
            addOnProductMappings.add(AddOnProductMapping.builder()
                    .productCode(addOnProductMappingVo.getProductCode())
                    .sfAddOnProductId(addOnProductMappingVo.getSfProductId())
                    .offerType(OfferType.OTHER)
                    .applicationMapping(applicationMapping)
                    .isActive(Boolean.TRUE)
                    .build());
        }

        addOnProductMappingRepository.saveAll(addOnProductMappings);

        if (sfSyncVo.getSfPayoutId() != null) {
            PayoutDetailsMapping payoutDetailsMapping = PayoutDetailsMapping.builder()
                    .sfPayoutId(sfSyncVo.getSfPayoutId())
                    .applicationMapping(applicationMapping)
                    .build();

            payoutDetailsMappingRepository.save(payoutDetailsMapping);
        }

        List<AddressMapping> addressMappingList = getAddressMappingList(sfSyncVo, applicantMapping);
        addressMappingRepository.saveAll(addressMappingList);
    }

    private static List<AddressMapping> getAddressMappingList(SfSyncVo sfSyncVo, ApplicantMapping applicantMapping) {
        List<AddressMapping> addressMappingList = new ArrayList<>();
        List<AddressMappingVo> addressMappingVoList = sfSyncVo.getAddressMappingVoList();
        addressMappingVoList.forEach(addressMappingVo -> addressMappingList.add(AddressMapping.builder()
                .sfAddressId(addressMappingVo.getSfAddressId())
                .addressId(addressMappingVo.getFosAddressId())
                .addressType(addressMappingVo.getAddressType())
                .applicantMapping(applicantMapping)
                .build()));
        return addressMappingList;
    }

    private CompositeRequest buildGetLoanChargeRequest(LoanCharge loanCharge) {
        String loanChargeId = loanCharge.getLoanChargeMaster().get(CHARGE_ID_C);
        return CompositeRequest.builder()
                .url(String.format(GET_LOAN_CHARGE.getUrl(), sfApiVersion, loanChargeId))
                .method(GET_LOAN_CHARGE.getMethod())
                .referenceId(String.format(GET_LOAN_CHARGE.getReferenceId(), loanChargeId))
                .build();
    }

    private CompositeRequest buildGetBankingRequest() {
        return CompositeRequest.builder()
                .url(String.format(GET_BANKING.getUrl(), sfApiVersion, CREATE_BANKING.getReferenceId()))
                .method(GET_BANKING.getMethod())
                .referenceId(GET_BANKING.getReferenceId())
                .build();
    }

    private CompositeRequest buildBankingRequest(BankingDetail bankingDetail, BankDetailsMapping bankingDetailId) {
        String sfBankingDetailId = Objects.isNull(bankingDetailId) ? null : bankingDetailId.getSfBankDetailsId();
        boolean isSyncAlreadyDone = nonNull(sfBankingDetailId);
        return CompositeRequest.builder()
                .url(getSyncResourceUrl(
                        isSyncAlreadyDone, CREATE_BANKING, UPDATE_BANKING_DETAILS, sfBankingDetailId, sfApiVersion))
                .body(bankingDetail)
                .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_BANKING, UPDATE_BANKING_DETAILS))
                .referenceId(CREATE_BANKING.getReferenceId())
                .build();
    }

    private CompositeRequest buildPostSanctionApplicantRequest(
            PostSanctionApplicant postSanctionApplicant, String sfApplicantId) {
        return CompositeRequest.builder()
                .url(String.format(UPDATE_APPLICANT.getUrl(), sfApiVersion, sfApplicantId))
                .body(postSanctionApplicant)
                .method(UPDATE_APPLICANT.getMethod())
                .referenceId(UPDATE_APPLICANT.getReferenceId())
                .build();
    }

    private CompositeRequest buildCoAppAndGuarantorPostSanctionApplicantRequest(
            PostSanctionApplicant postSanctionApplicant, String sfApplicantId, int referenceId) {
        return CompositeRequest.builder()
                .url(String.format(UPDATE_APPLICANT.getUrl(), sfApiVersion, sfApplicantId))
                .body(postSanctionApplicant)
                .method(UPDATE_APPLICANT.getMethod())
                .referenceId(UPDATE_APPLICANT.getReferenceId() + referenceId)
                .build();
    }

    private CompositeRequest buildApplicantRequest(Applicant applicant, ApplicantMapping applicantMapping) {
        boolean isSyncAlreadyDone = nonNull(applicantMapping);
        String sfApplicantId = isNull(applicantMapping) ? null : applicantMapping.getSfApplicantId();
        return CompositeRequest.builder()
                .url(getSyncResourceUrl(
                        isSyncAlreadyDone, CREATE_APPLICANT, UPDATE_APPLICANT, sfApplicantId, sfApiVersion))
                .body(applicant)
                .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_APPLICANT, UPDATE_APPLICANT))
                .referenceId(CREATE_APPLICANT.getReferenceId())
                .build();
    }

    private CompositeRequest buildAddOnProductCreateRequestForMas(AddOnProduct addOnProduct) {
        return CompositeRequest.builder()
                .url(String.format(CREATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion))
                .body(addOnProduct)
                .method(CREATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(CREATE_ADD_ON_PRODUCTS.getReferenceId(), "1"))
                .build();
    }

    private CompositeRequest buildAddOnProductCreateRequestForMls(AddOnProduct addOnProduct) {
        return CompositeRequest.builder()
                .url(String.format(CREATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion))
                .body(addOnProduct)
                .method(CREATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(CREATE_ADD_ON_PRODUCTS.getReferenceId(), "2"))
                .build();
    }

    private CompositeRequest buildAddOnProductUpdateRequestForMas(AddOnProduct addOnProduct, String productId) {
        return CompositeRequest.builder()
                .url(String.format(UPDATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion, productId))
                .body(addOnProduct)
                .method(UPDATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(UPDATE_ADD_ON_PRODUCTS.getReferenceId(), "1"))
                .build();
    }

    private CompositeRequest buildAddOnProductUpdateRequestForMls(AddOnProduct addOnProduct, String productId) {
        return CompositeRequest.builder()
                .url(String.format(UPDATE_ADD_ON_PRODUCTS.getUrl(), sfApiVersion, productId))
                .body(addOnProduct)
                .method(UPDATE_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(UPDATE_ADD_ON_PRODUCTS.getReferenceId(), "2"))
                .build();
    }

    private CompositeRequest buildAddOnProductGetRequest(String referenceNo) {
        return CompositeRequest.builder()
                .url(String.format(GET_ADD_ON_PRODUCTS.getUrl(), sfApiVersion, referenceNo))
                .method(GET_ADD_ON_PRODUCTS.getMethod())
                .referenceId(String.format(GET_ADD_ON_PRODUCTS.getReferenceId(), referenceNo))
                .build();
    }

    private CompositeRequest buildPostSanctionApplicationRequest(
            PostSanctionLoanApplication postSanctionLoanApplication, String applicationId) {
        return CompositeRequest.builder()
                .url(String.format(CREATE_APPLICATION.getUrl(), sfApiVersion) + applicationId)
                .body(postSanctionLoanApplication)
                .method(CREATE_APPLICATION.getMethod())
                .referenceId(CREATE_APPLICATION.getReferenceId())
                .build();
    }

    private CompositeRequest buildBureauResponse(
            BureauResponse bureauResponse, BureauResponseMapping bureauResponseMapping) {
        String sfBureauResponseId =
                Objects.isNull(bureauResponseMapping) ? null : bureauResponseMapping.getSfBureauResponseId();
        boolean isSyncAlreadyDone = nonNull(bureauResponseMapping);
        return CompositeRequest.builder()
                .url(getSyncResourceUrl(
                        isSyncAlreadyDone,
                        CREATE_BUREAU_RESPONSE,
                        UPDATE_BUREAU_RESPONSE,
                        sfBureauResponseId,
                        sfApiVersion))
                .body(bureauResponse)
                .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_BUREAU_RESPONSE, UPDATE_BUREAU_RESPONSE))
                .referenceId(CREATE_BUREAU_RESPONSE.getReferenceId())
                .build();
    }

    private CompositeRequest buildCoAppAndGuarantorBureauResponse(
            BureauResponse bureauResponse,
            BureauResponseMapping bureauResponseMapping,
            String customerType,
            String paramKey) {
        String sfBureauResponseId =
                isNull(bureauResponseMapping) ? null : bureauResponseMapping.getSfBureauResponseId();
        boolean isSyncAlreadyDone = nonNull(bureauResponseMapping);

        return CompositeRequest.builder()
                .url(getSyncResourceUrl(
                        isSyncAlreadyDone,
                        CREATE_CO_APPLICANT_BUREAU_RESPONSE,
                        UPDATE_CO_APPLICANT_BUREAU_RESPONSE,
                        sfBureauResponseId,
                        sfApiVersion))
                .body(bureauResponse)
                .method(getCoAppAndGuarantorSyncResourceMethod(
                        isSyncAlreadyDone, CREATE_CO_APPLICANT_BUREAU_RESPONSE, UPDATE_CO_APPLICANT_BUREAU_RESPONSE))
                .referenceId(String.format(
                        CREATE_CO_APPLICANT_BUREAU_RESPONSE.getReferenceId(),
                        customerType.replace("-", ""),
                        extractNumberFromRefereenceId(paramKey)))
                .build();
    }

    private CompositeRequest buildGetBureauResponse() {
        return CompositeRequest.builder()
                .url(String.format(GET_BUREAU_RESPONSE.getUrl(), sfApiVersion, GET_BUREAU_RESPONSE.getReferenceId()))
                .method(GET_BUREAU_RESPONSE.getMethod())
                .referenceId(GET_BUREAU_RESPONSE.getReferenceId())
                .build();
    }

    private CompositeRequest buildCoAppAndGuarantorGetBureauResponse(
            String customerType, String paramGetKey, String paramKey) {
        return CompositeRequest.builder()
                .url(String.format(
                        GET_CO_APPLICANT_BUREAU_RESPONSE.getUrl(), sfApiVersion, paramGetKey.replace("-", "")))
                .method(GET_CO_APPLICANT_BUREAU_RESPONSE.getMethod())
                .referenceId(String.format(
                        GET_CO_APPLICANT_BUREAU_RESPONSE.getReferenceId(),
                        customerType.replace("-", ""),
                        extractNumberFromRefereenceId(paramKey)))
                .build();
    }

    public void saveDdeDataToDb(SfSyncVo sfSyncVo) {
        ApplicationMapping applicationMapping = sfSyncVo.getApplicationMapping();
        List<ChargeMapping> chargeMappingList = new ArrayList<>();
        Map<String, String> fosAndSfChargeIdMapping = sfSyncVo.getFosAndSfChargeIdMapping();

        fosAndSfChargeIdMapping
                .keySet()
                .forEach(fosChargeId -> chargeMappingList.add(ChargeMapping.builder()
                        .applicationMapping(applicationMapping)
                        .sfChargeId(fosAndSfChargeIdMapping.get(fosChargeId))
                        .chargeId(fosChargeId)
                        .build()));
        sfSyncVo.getSfLoanChargeIds()
                .forEach(loanCharge -> chargeMappingList.add(ChargeMapping.builder()
                        .applicationMapping(applicationMapping)
                        .sfChargeId(loanCharge)
                        .build()));

        if (nonNull(sfSyncVo.getBankDetailsId())) {
            BankDetailsMapping bankDetailsMapping = BankDetailsMapping.builder()
                    .sfBankDetailsId(sfSyncVo.getSfBankDetailsId())
                    .applicationMapping(applicationMapping)
                    .bankDetailsId(sfSyncVo.getBankDetailsId().toString())
                    .build();
            List<BankDetailsMapping> bankDetailsMappingsList = new ArrayList<>();
            bankDetailsMappingsList.add(bankDetailsMapping);
            bankDetailsMappingRepository.saveAll(bankDetailsMappingsList);
        }

        chargeMappingRepository.deleteAll(sfSyncVo.getChargeMappingsToBeDeleted());
        chargeMappingRepository.saveAll(chargeMappingList);

        applicationMapping.setRePayerId(sfSyncVo.getRePayerCustomerId());
        applicationMappingRepository.save(applicationMapping);
    }

    private static boolean isCibilDetailsAvailable(CustomerResponse customer) {
        return nonNull(customer.getBureauResponse())
                && nonNull(customer.getBureauResponse().cibilResponse());
    }

    private ApplicationMapping saveApplicationMapping(SfSyncVo sfSyncVo) {
        ApplicationMapping applicationMapping = applicationMappingRepository
                .findByApplicationId(sfSyncVo.getApplicationId())
                .orElse(ApplicationMapping.builder()
                        .applicationId(sfSyncVo.getApplicationId())
                        .build());

        return applicationMappingRepository.save(applicationMapping);
    }

    public ApplicationState getApplicationState(String applicationId) {
        MfResponse<StatusResponse> statusResponseMfResponse =
                loanClient.getStatus(applicationId).block();
        return statusResponseMfResponse == null
                ? null
                : statusResponseMfResponse.getData().getApplicationStatus();
    }

    private void saveCaseHistoryForDDECPCSubmission(String applicationId, ApplicationState applicationStatus) {
        if (ApplicationState.DDE.equals(applicationStatus))
            caseHistoryService.saveCPCSentBackForSubmittedApplication(applicationId);
    }

    private CompositeRequest buildCoApplicantAndGuarantorRequest(
            Applicant applicant, ApplicantMapping applicantMapping, String customerType, String customerNumber) {
        boolean isSyncAlreadyDone = nonNull(applicantMapping);
        String sfApplicantId = isNull(applicantMapping) ? null : applicantMapping.getSfApplicantId();
        CompositeRequest compositeRequest;
        switch (customerType) {
            case CO_APPLICANT -> {
                compositeRequest = CompositeRequest.builder()
                        .url(getSyncResourceUrl(
                                isSyncAlreadyDone, CREATE_APPLICANT, UPDATE_APPLICANT, sfApplicantId, sfApiVersion))
                        .body(applicant)
                        .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_APPLICANT, UPDATE_APPLICANT))
                        .referenceId(String.format(CREATE_CO_APPLICANT.getReferenceId(), customerNumber))
                        .build();
            }
            case GUARANTOR -> {
                compositeRequest = CompositeRequest.builder()
                        .url(getSyncResourceUrl(
                                isSyncAlreadyDone, CREATE_APPLICANT, UPDATE_APPLICANT, sfApplicantId, sfApiVersion))
                        .body(applicant)
                        .method(getSyncResourceMethod(isSyncAlreadyDone, CREATE_APPLICANT, UPDATE_APPLICANT))
                        .referenceId(String.format(CREATE_GUARANTOR.getReferenceId(), customerNumber))
                        .build();
            }

            default -> throw new IllegalStateException("Unexpected value: " + customerType);
        }
        ;
        return compositeRequest;
    }

    private Long extractNumberFromRefereenceId(String referenceId) {
        return Long.parseLong(referenceId.replaceAll("[^0-9]", ""));
    }

    private KycVerificationDetailsResponse getKycVerificationDetails(String applicationId) {
        KycVerificationDetailsResponse kycVerificationDetailsResponse = new KycVerificationDetailsResponse();
        try {
            kycVerificationDetailsResponse =
                    kycClient.fetchKycVerificationDetails(applicationId).getData();
        } catch (Exception e) {
            return KycVerificationDetailsResponse.builder().build();
        }
        return kycVerificationDetailsResponse;
    }
}


















----------------------------------
code for SfClientTest.java


package com.mahindrafinance.fos.service.sfsync;

import static com.mahindrafinance.fos.commons.enums.Language.ENGLISH;
import static com.mahindrafinance.fos.exceptions.MfErrorCode.*;
import static com.mahindrafinance.fos.master.enums.SfSyncStage.*;
import static com.mahindrafinance.fos.testdata.DisbursementSyncServiceTestData.buildThreeDocumentsOnSF;
import static com.mahindrafinance.fos.testdata.DisbursementsTestData.*;
import static com.mahindrafinance.fos.testdata.SfDocSyncTestData.buildDocDmsIdMappingListResponse;
import static com.mahindrafinance.fos.testdata.SfDocSyncTestData.buildDocDmsIdMappingResponse;
import static com.mahindrafinance.fos.testdata.SfSyncTestData.*;
import static com.mahindrafinance.fos.testdata.SfSyncTestData.buildInsuranceResponse;
import static com.mahindrafinance.fos.util.Constants.BUREAU_RESPONSE;
import static com.mahindrafinance.fos.util.enums.AddressType.*;
import static org.apache.commons.lang3.BooleanUtils.TRUE;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isA;
import static org.mockito.Mockito.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mahindrafinance.fos.api.sentback.service.SentBackService;
import com.mahindrafinance.fos.api.sfsync.response.SfSyncResponse;
import com.mahindrafinance.fos.client.consent.ConsentClient;
import com.mahindrafinance.fos.client.customer.CustomerClient;
import com.mahindrafinance.fos.client.customer.response.AmlResponse;
import com.mahindrafinance.fos.client.customer.response.DedupeAndExposureResponse;
import com.mahindrafinance.fos.client.document.DocResponse;
import com.mahindrafinance.fos.client.document.DocumentClient;
import com.mahindrafinance.fos.client.kyc.KycClient;
import com.mahindrafinance.fos.client.lead.LeadClient;
import com.mahindrafinance.fos.client.loan.LoanClient;
import com.mahindrafinance.fos.client.loan.response.*;
import com.mahindrafinance.fos.client.master.MasterDataClient;
import com.mahindrafinance.fos.client.offer.OfferClient;
import com.mahindrafinance.fos.client.offer.response.InsuranceResponse;
import com.mahindrafinance.fos.client.offer.response.OfferDetails;
import com.mahindrafinance.fos.client.offer.response.OfferResponse;
import com.mahindrafinance.fos.client.sfsync.SfClient;
import com.mahindrafinance.fos.client.sfsync.request.Applicant;
import com.mahindrafinance.fos.client.sfsync.request.CompositeRequest;
import com.mahindrafinance.fos.client.sfsync.request.GraphRequest;
import com.mahindrafinance.fos.client.sfsync.request.LoanApplication;
import com.mahindrafinance.fos.client.sfsync.response.Graph;
import com.mahindrafinance.fos.client.sfsync.response.GraphResponseDetail;
import com.mahindrafinance.fos.client.user.UserServiceClient;
import com.mahindrafinance.fos.client.user.response.UserData;
import com.mahindrafinance.fos.client.user.response.UserDetails;
import com.mahindrafinance.fos.commons.api.response.MfResponse;
import com.mahindrafinance.fos.commons.enums.ApplicationState;
import com.mahindrafinance.fos.commons.exceptions.ExternalServiceResponseException;
import com.mahindrafinance.fos.commons.exceptions.InvalidRequestException;
import com.mahindrafinance.fos.exceptions.DocumentNotFoundException;
import com.mahindrafinance.fos.exceptions.SfSyncException;
import com.mahindrafinance.fos.master.enums.SfSyncStage;
import com.mahindrafinance.fos.repository.*;
import com.mahindrafinance.fos.repository.entity.AddressMapping;
import com.mahindrafinance.fos.repository.entity.ApplicantMapping;
import com.mahindrafinance.fos.repository.entity.ApplicationMapping;
import com.mahindrafinance.fos.repository.entity.DocReferenceIdMapping;
import com.mahindrafinance.fos.service.casehistory.CaseHistoryService;
import com.mahindrafinance.fos.service.sfsync.builders.ApplicantFinancialsObjectRequestBuilder;
import com.mahindrafinance.fos.service.sfsync.handlers.ApplicantFinancialsRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.CPVRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.ConditionAndDeviationRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.IncomeAssessmentRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.PayoutRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.RepaymentRequestHandler;
import com.mahindrafinance.fos.service.sfsync.handlers.WithdrawalRequestHandler;
import com.mahindrafinance.fos.testdata.SfSyncTestData;
import com.mahindrafinance.fos.util.enums.CustomerType;
import com.mahindrafinance.fos.util.enums.KycDocumentType;
import java.lang.reflect.Field;
import java.util.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;

@ExtendWith(MockitoExtension.class)
class SfServiceTest {
    private static final String APPLICATION_ID = "AGR001";
    private static final String applicantId = "6a82a23f-4b1f-11ef-a6fc-496a324590c0";
    private static final String leadId = "LEAD001";
    private static final String userId = "UI5468";
    private static final String mobileNumber = "7865456789";
    private static final String userName = "iopa";
    private static final String docId = "458fb651-b1c3-4773-be27-a6b1c98b21ff";
    private static final UUID customerId = UUID.fromString("7cc29190-14af-4b4b-b337-8569c98504e7");
    private static final UUID ifscCodeUuid = UUID.fromString("470356a0-2b99-11ee-be56-0242ac120002");
    private static final Set<String> additionalParams = Set.of("ucicIdResponse");
    private static final Set<String> additionalParamsWithNameAndAddressStrength =
            Set.of("ucicIdResponse", "nameStrengthResponse", "triangulationResponse", BUREAU_RESPONSE);
    public static final String SF_ADDRESS_ID = "sfAddressId";
    private static final UUID customerIdCoApp = UUID.fromString("8109e243-4930-4d80-9eec-581c2688d438");

    private SfService sfService;

    @Mock
    private KycClient kycClient;

    @Mock
    private LoanClient loanClient;

    @Mock
    private LeadClient leadClient;

    @Mock
    private CustomerClient customerClient;

    @Mock
    private ConsentClient consentClient;

    @Mock
    private SfClient sfClient;

    @Mock
    private MasterDataClient masterDataClient;

    @Mock
    private UserServiceClient userServiceClient;

    @Mock
    private OfferClient offerClient;

    @Mock
    private SfPreDoCpcSyncService sfPreDoCpcSyncService;

    @Mock
    private DocumentClient documentClient;

    @Mock
    private SfDocSyncService sfDocSyncService;

    @Mock
    private UnderwriterApprovalService underwriterApprovalService;

    @Mock
    private SentBackService sentBackService;

    @Mock
    private RepaymentRequestHandler repaymentRequestHandler;

    @Mock
    private ApplicationMappingRepository applicationMappingRepository;

    @Mock
    private AddOnProductMappingRepository addOnProductMappingRepository;

    @Mock
    private ApplicantMappingRepository applicantMappingRepository;

    @Mock
    private DocReferenceIdMappingRepository docReferenceIdMappingRepository;

    @Mock
    private ChecklistIdMappingRepository checklistIdMappingRepository;

    @Mock
    private LoanAssetMappingRepository loanAssetMappingRepository;

    @Mock
    private BankDetailsMappingRepository bankDetailsMappingRepository;

    @Mock
    private AddressMappingRepository addressMappingRepository;

    @Mock
    private BureauResponseMappingRepository bureauResponseMappingRepository;

    @Mock
    private ChargeMappingRepository chargeMappingRepository;

    @Mock
    private PayoutDetailsMappingRepository payoutDetailsMappingRepository;

    @Mock
    private IncomeAssessmentRequestHandler incomeAssessmentRequestHandler;

    @Captor
    private ArgumentCaptor<GraphRequest> graphRequestArgumentCaptor;

    @Mock
    private ConditionAndDeviationRequestHandler conditionAndDeviationRequestHandler;

    @Mock
    private SfBreOutputSyncService sfBreOutputSyncService;

    @Mock
    private CaseHistoryService caseHistoryService;

    @Mock
    private CPVRequestHandler cpvRequestHandler;

    @Mock
    private SfPreDoDocSyncService sfPreDoDocSyncService;

    @Mock
    private WithdrawalRequestHandler withdrawalRequestHandler;

    @Mock
    private LoanSanctionDateRequestHandler loanSanctionDateRequestHandler;

    @Mock
    private ApplicantFinancialsRequestHandler applicantFinancialsRequestHandler;

    @Mock
    private InsuredDetailService insuredDetailService;

    @Mock
    private PayoutRequestHandler payoutRequestHandler;

    @Captor
    private ArgumentCaptor<List<String>> strIterCaptor;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    void setUp() {
        sfService = new SfService(
                loanClient,
                leadClient,
                kycClient,
                customerClient,
                consentClient,
                sfClient,
                documentClient,
                sfDocSyncService,
                sfPreDoDocSyncService,
                underwriterApprovalService,
                objectMapper,
                masterDataClient,
                userServiceClient,
                offerClient,
                sfPreDoCpcSyncService,
                sentBackService,
                insuredDetailService,
                applicationMappingRepository,
                addOnProductMappingRepository,
                applicantMappingRepository,
                docReferenceIdMappingRepository,
                checklistIdMappingRepository,
                repaymentRequestHandler,
                loanAssetMappingRepository,
                chargeMappingRepository,
                bankDetailsMappingRepository,
                incomeAssessmentRequestHandler,
                sfBreOutputSyncService,
                caseHistoryService,
                cpvRequestHandler,
                conditionAndDeviationRequestHandler,
                addressMappingRepository,
                bureauResponseMappingRepository,
                withdrawalRequestHandler,
                loanSanctionDateRequestHandler,
                applicantFinancialsRequestHandler,
                payoutRequestHandler,
                payoutDetailsMappingRepository);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenAddressesNotSynced() throws JsonProcessingException {
        commonMockForUptoQde1StageSfSync();
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());

        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertFalse(applicant.getPanIdDV());
        assertFalse(applicant.getFirstNameDV());
        assertFalse(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenDocumentUploaded() throws JsonProcessingException {
        when(sfDocSyncService.syncDocUploadDataToSf(any(), any())).thenReturn(new SfSyncResponse());
        when(loanClient.getStatus(any()))
                .thenReturn(Mono.just(MfResponse.ok(StatusResponse.builder()
                        .applicationStatus(ApplicationState.CREATED)
                        .build())));
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, DOC_UPLOAD);
        assertNotNull(sfSyncResponse);
    }

    @Test
    void shouldSyncPayoutDataToSfSuccessfully() throws JsonProcessingException {
        commonMockForUptoQde1StageSfSync();
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());
        verify(payoutRequestHandler).addPayoutRequests(eq(APPLICATION_ID), any(), anyList());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenAddressesAlreadySynced() throws JsonProcessingException {
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetails()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());

        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertFalse(applicant.getPanIdDV());
        assertFalse(applicant.getFirstNameDV());
        assertFalse(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
    }

    @Test
    void shouldNotSyncQDEDataIfKycDetailsNotFoundForAKycCompletedApplication() {
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(new ArrayList<>()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));

        DocumentNotFoundException documentNotFoundException =
                assertThrows(DocumentNotFoundException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));
        assertEquals(KYC_DOCUMENT_NOT_FOUND, documentNotFoundException.getErrorCode());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhileForm60() throws JsonProcessingException {
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .build();
        AddressMapping permanentAddressMapping = AddressMapping.builder()
                .sfAddressId(SF_ADDRESS_ID)
                .addressId(UUID.randomUUID())
                .applicantMapping(applicantMapping)
                .addressType(PERMANENT)
                .build();
        AddressMapping currentAddressMapping = AddressMapping.builder()
                .sfAddressId(SF_ADDRESS_ID)
                .addressId(UUID.randomUUID())
                .applicantMapping(applicantMapping)
                .addressType(CURRENT)
                .build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        loanDetailsResponse.getCustomerDetails().getFirst().getKycDetails().setForm60Available(true);

        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));

        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));

        loanDetailsResponse.getCustomerDetails().getFirst().getKycDetails().setForm60Available(true);

        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetailsWithoutPan()));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        doReturn(Optional.of(applicantMapping))
                .when(applicantMappingRepository)
                .findByApplicationMappingApplicationIdAndApplicantId(APPLICATION_ID, customerId);
        when(customerClient.fetchDedupeAndExposure(customerId))
                .thenReturn(DedupeAndExposureResponse.builder().build());
        doReturn(Optional.of(List.of(permanentAddressMapping, currentAddressMapping)))
                .when(addressMappingRepository)
                .findByApplicantMappingApplicantId(UUID.fromString(applicantId));

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());

        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertTrue(applicant.getPanIdDV());
        assertFalse(applicant.getFirstNameDV());
        assertFalse(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForSameCurrentAndPermanentAddress() throws JsonProcessingException {
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        loanDetailsResponse.getCustomerDetails().getFirst().getKycDetails().setForm60Available(true);
        ApplicantMapping applicantMapping =
                ApplicantMapping.builder().sfApplicantId("ABCD").build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        loanDetailsResponse.getCustomerDetails().get(0).getKycDetails().setForm60Available(true);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetailsWithoutPan()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponseForSameCurrentAndPermanentAddress(
                        mobileNumber, customerId.toString())));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());

        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertTrue(applicant.getPanIdDV());
        assertFalse(applicant.getFirstNameDV());
        assertFalse(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
        var permanentAddress =
                graphRequestArgumentCaptor.getValue().getGraphs().getFirst().getCompositeRequest().stream()
                        .filter(request -> request.getReferenceId().equals("refAddressPermanent"))
                        .findFirst();
        var currentAddress = graphRequestArgumentCaptor.getValue().getGraphs().getFirst().getCompositeRequest().stream()
                .filter(request -> request.getReferenceId().equals("refAddressCurrent"))
                .findFirst();
        var workAddress = graphRequestArgumentCaptor.getValue().getGraphs().getFirst().getCompositeRequest().stream()
                .filter(request -> request.getReferenceId().equals("refAddressWork"))
                .findFirst();
        assertNotNull(permanentAddress);
        assertNotNull(currentAddress);
        assertNotNull(workAddress);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForRepaymentSchedule() throws JsonProcessingException {
        when(repaymentRequestHandler.syncJob(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, REPAYMENT_SCHEDULE);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForCPV() throws JsonProcessingException {
        when(cpvRequestHandler.syncJob(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, CPV);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForBreOutput() throws JsonProcessingException {
        when(sfBreOutputSyncService.syncBreOutput(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, BRE_OUTPUT);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForIncomeAssessment() throws JsonProcessingException {
        when(incomeAssessmentRequestHandler.syncJob(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, INCOME_ASSESSMENT);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldNotSyncDataToSfIfFetchActiveLoanDetailsIsFailed() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenThrow(new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient, times(0)).fetchLoanDetails(any());
        verify(kycClient, times(0)).fetchKycDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(consentClient, times(0)).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncDataToSfIfFetchLoanDetailsIsFailed() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(new LoanInfoResponse()));
        when(loanClient.fetchLoanDetails(APPLICATION_ID))
                .thenThrow(new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient, times(0)).fetchKycDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(consentClient, times(0)).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncDataToSfIfFetchKycDetailsOfACustomerIsFailed() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(new LoanInfoResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(kycClient.fetchKycDetails(customerId))
                .thenThrow(new ExternalServiceResponseException(KYC_SERVICE_FETCH_KYC_DETAILS_INVALID_RESPONSE));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(KYC_SERVICE_FETCH_KYC_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(consentClient, times(0)).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncQdeDataToSfIfFetchCustomerDetailsIsFailed() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(new LoanInfoResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(new MfResponse<>());
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenThrow(
                        new ExternalServiceResponseException(CUSTOMER_SERVICE_FETCH_CUSTOMER_DETAILS_INVALID_RESPONSE));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(CUSTOMER_SERVICE_FETCH_CUSTOMER_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(consentClient, times(0)).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncDataToSfIfFetchActiveLoanDetailsResponseDoesNotHavePrimaryCustomerDetails() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(new LoanInfoResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.GUARANTOR, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));

        InvalidRequestException exception =
                assertThrows(InvalidRequestException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(PRIMARY_CUSTOMER_ID_NOT_FOUND.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient, times(0)).fetchKycDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(consentClient, times(0)).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncDataToSfIfCustomerDetailsNotFoundInFetchActiveLoanDetailsResponse() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(new LoanInfoResponse()));
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(new LoanDetailsResponse()));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_CUSTOMER_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient, times(0)).fetchKycDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(consentClient, times(0)).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncDataToSfIfFetchConsentDetailsIsFailed() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(new MfResponse<>());
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenThrow(
                        new ExternalServiceResponseException(CONSENT_SERVICE_FETCH_CONSENT_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(CONSENT_SERVICE_FETCH_CONSENT_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(consentClient).getConsentDetails(any(), any());
        verify(userServiceClient, times(0)).fetchUserDetails(any());
    }

    @Test
    void shouldNotSyncDataToSfIfFetchUserDetailsIsFailed() {
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));

        when(kycClient.fetchKycDetails(customerId)).thenReturn(new MfResponse<>());
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenThrow(new ExternalServiceResponseException(USER_SERVICE_FETCH_USER_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        assertEquals(USER_SERVICE_FETCH_USER_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(consentClient).getConsentDetails(any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncDataIfSfSyncApiGivesErrorResponse() throws JsonProcessingException {
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping =
                ApplicantMapping.builder().sfApplicantId("ABCD").build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();

        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));

        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetails()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildErrorGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());
        SfSyncException exception =
                assertThrows(SfSyncException.class, () -> sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1));

        String expectedErrorMessage = "Foreign key external ID: 001 not found for field "
                + "Dealer_Code__c in entity Account, LA-ERR-10 : These Fields are uneditable Lead Id, BE Code, MMFSL Executive Name, Application Id, Loan Created Date";
        assertEquals(expectedErrorMessage, exception.getMessage());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(consentClient).getConsentDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());
    }

    @Test
    void shouldSyncPostSanctionDataToSfSuccessfully() throws JsonProcessingException {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenReturn(MfResponse.ok(buildDisbursementBankDetailResponse()));
        when(loanClient.fetchLoanChargeDetails(any(), any()))
                .thenReturn(MfResponse.ok(buildLoanChargeResponse(APPLICATION_ID)));
        lenient()
                .when(loanClient.fetchAccountVerificationDetails(APPLICATION_ID, customerId.toString()))
                .thenReturn(MfResponse.ok(buildAccountVerificationDetailsResponse(APPLICATION_ID)));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, DDE);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient).fetchLoanChargeDetails(any(), any());
        verify(offerClient).getOffers(APPLICATION_ID, true);
        verify(payoutRequestHandler)
                .addUpdatePayoutDetailsRequest(eq(APPLICATION_ID), eq(loanDetailsResponse), anyList());
        verify(sfClient).postToSf(any());
    }

    @Test
    void shouldSyncPostSanctionDataToSfSuccessfullyIfBankDetailsIsNull() throws JsonProcessingException {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponseWithoutBankingResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(loanClient.fetchLoanChargeDetails(any(), any()))
                .thenReturn(MfResponse.ok(buildLoanChargeResponse(APPLICATION_ID)));
        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));
        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));

        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, DDE);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient).fetchLoanChargeDetails(any(), any());
        verify(offerClient).getOffers(APPLICATION_ID, true);
        verify(payoutRequestHandler)
                .addUpdatePayoutDetailsRequest(eq(APPLICATION_ID), eq(loanDetailsResponse), anyList());
        verify(sfClient).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfApplicationNotFoundInDb() {
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID)).thenReturn(Optional.empty());
        InvalidRequestException exception = assertThrows(
                InvalidRequestException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        assertEquals(SF_APPLICATION_MAPPING_NOT_FOUND.getMessage(), exception.getMessage());

        verify(loanClient, times(0)).fetchPostSanctionLoanDetails(any());
        verify(loanClient, times(0)).fetchLoanDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchLoanDetailsIsFailed() {
        when(loanClient.fetchLoanDetails(APPLICATION_ID))
                .thenThrow(new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE));
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient, times(0)).fetchPostSanctionLoanDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchPostSanctionLoanDetailsIsFailed() {
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenThrow(new ExternalServiceResponseException(
                        LOAN_SERVICE_FETCH_POST_SANCTION_LOAN_DETAILS_INVALID_RESPONSE));
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        assertEquals(
                LOAN_SERVICE_FETCH_POST_SANCTION_LOAN_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchCustomerDetailsIsFailed() {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        when(customerClient.fetchCustomerDetails(customerId, Set.of("ucicIdResponse")))
                .thenThrow(
                        new ExternalServiceResponseException(CUSTOMER_SERVICE_FETCH_CUSTOMER_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        assertEquals(CUSTOMER_SERVICE_FETCH_CUSTOMER_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchDisbursementBankDetailsIsFailed() {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenThrow(new ExternalServiceResponseException(MASTER_SERVICE_FETCH_BANK_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        assertEquals(MASTER_SERVICE_FETCH_BANK_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchLoanChargeDetailsIsFailed() {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenReturn(MfResponse.ok(buildDisbursementBankDetailResponse()));
        when(loanClient.fetchLoanChargeDetails(any(), any()))
                .thenThrow(
                        new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_CHARGE_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_CHARGE_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient).fetchLoanChargeDetails(any(), any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataIfSfSyncApiGivesErrorResponse() throws JsonProcessingException {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenReturn(MfResponse.ok(buildDisbursementBankDetailResponse()));
        when(loanClient.fetchLoanChargeDetails(any(), any()))
                .thenReturn(MfResponse.ok(buildLoanChargeResponse(APPLICATION_ID)));
        lenient()
                .when(loanClient.fetchAccountVerificationDetails(APPLICATION_ID, customerId.toString()))
                .thenReturn(MfResponse.ok(buildAccountVerificationDetailsResponse(APPLICATION_ID)));
        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildErrorGraphResponseDetail());
        assertThrows(SfSyncException.class, () -> sfService.syncDataToSf(APPLICATION_ID, SfSyncStage.DDE));

        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient).fetchLoanChargeDetails(any(), any());
        verify(offerClient).getOffers(APPLICATION_ID, true);
        verify(payoutRequestHandler)
                .addUpdatePayoutDetailsRequest(eq(APPLICATION_ID), eq(loanDetailsResponse), anyList());
        verify(sfClient).postToSf(any());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenEkycIsDone() throws JsonProcessingException {
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping =
                ApplicantMapping.builder().sfApplicantId("ABCD").build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        KycDetailsResponse kycDetails =
                loanDetailsResponse.getCustomerDetails().get(0).getKycDetails();
        kycDetails.setPoiType(KycDocumentType.AADHAAR.name());
        kycDetails.setPoaType(KycDocumentType.AADHAAR.name());

        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId))
                .thenReturn(MfResponse.ok(
                        buildKycDetailsForEkyc(KycDocumentType.AADHAAR, KycDocumentType.AADHAAR, "123456781234")));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertFalse(applicant.getPanIdDV());
        assertTrue(applicant.getFirstNameDV());
        assertTrue(applicant.getLastNameDV());
        assertFalse(applicant.getMiddleNameDV());
        assertTrue(applicant.getGenderDV());
        assertTrue(applicant.getPoiIdDV());
        assertTrue(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenEkycIsDoneAndVirtualIdIsPresent() throws JsonProcessingException {
        String virtualId = "1234567812345678";
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping =
                ApplicantMapping.builder().sfApplicantId("ABCD").build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        KycDetailsResponse kycDetails =
                loanDetailsResponse.getCustomerDetails().get(0).getKycDetails();
        kycDetails.setPoiType(KycDocumentType.AADHAAR.name());
        kycDetails.setPoaType(KycDocumentType.PASSPORT.name());

        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId))
                .thenReturn(MfResponse.ok(
                        buildKycDetailsForEkyc(KycDocumentType.AADHAAR, KycDocumentType.PASSPORT, virtualId)));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .get(0)
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertFalse(applicant.getPanIdDV());
        assertTrue(applicant.getFirstNameDV());
        assertTrue(applicant.getLastNameDV());
        assertFalse(applicant.getMiddleNameDV());
        assertTrue(applicant.getGenderDV());
        assertTrue(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertEquals(virtualId, applicant.getVirtualId());
    }

    @Test
    void shouldSyncQDEDataSuccessfullyWhenPrimaryOrSecondaryPayoutIsNull() throws JsonProcessingException {
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .build();

        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(any())).thenReturn(MfResponse.ok(buildKycDetails()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldSyncDateSuccessfullyWhenConditionAndDeviationAreGiven() throws JsonProcessingException {
        SfSyncResponse sfSuccessSyncResponse =
                SfSyncResponse.builder().isSuccessful(TRUE).build();

        when(conditionAndDeviationRequestHandler.syncJob(APPLICATION_ID)).thenReturn(sfSuccessSyncResponse);

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, CONDITION_AND_DEVIATION);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());

        verify(conditionAndDeviationRequestHandler, times(1)).syncJob(APPLICATION_ID);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenBureauResponseAvailable() throws JsonProcessingException {
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        AddressMapping permanentAddressMapping = AddressMapping.builder()
                .sfAddressId(SF_ADDRESS_ID)
                .addressId(UUID.randomUUID())
                .applicantMapping(applicantMapping)
                .addressType(PERMANENT)
                .build();
        AddressMapping currentAddressMapping = AddressMapping.builder()
                .sfAddressId(SF_ADDRESS_ID)
                .addressId(UUID.randomUUID())
                .applicantMapping(applicantMapping)
                .addressType(CURRENT)
                .build();

        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(APPLICATION_ID, customerId))
                .thenReturn(Optional.of(applicantMapping));
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetails()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());

        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertFalse(applicant.getPanIdDV());
        assertFalse(applicant.getFirstNameDV());
        assertFalse(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
    }

    @Test
    void shouldSyncDataToSfForDocUploadStageAndCreateCaseHistoryIfApplicationStateIsDDE()
            throws JsonProcessingException {
        when(loanClient.getStatus(APPLICATION_ID))
                .thenReturn(Mono.just(MfResponse.ok(StatusResponse.builder()
                        .applicationStatus(ApplicationState.DDE)
                        .build())));
        when(sfDocSyncService.syncDocUploadDataToSf(APPLICATION_ID, ApplicationState.DDE))
                .thenReturn(SfSyncResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, DOC_UPLOAD);
        assertThat(sfSyncResponse).isNotNull();

        verify(sfDocSyncService).syncDocUploadDataToSf(APPLICATION_ID, ApplicationState.DDE);
        verify(caseHistoryService).saveCPCSentBackForSubmittedApplication(APPLICATION_ID);
    }

    @Test
    void shouldSyncDataToSfForDocUploadStageAndCreateCaseHistoryIfApplicationStateIsDDEV2()
            throws JsonProcessingException {
        when(loanClient.getStatus(APPLICATION_ID))
                .thenReturn(Mono.just(MfResponse.ok(StatusResponse.builder()
                        .applicationStatus(ApplicationState.DDE)
                        .build())));
        when(sfDocSyncService.syncDocUploadDataToSf(APPLICATION_ID, ApplicationState.DDE, customerId.toString()))
                .thenReturn(SfSyncResponse.builder().build());

        SfSyncResponse sfSyncResponse =
                sfService.getSynchronousSfSyncResponse(APPLICATION_ID, DOC_UPLOAD, customerId.toString());
        assertThat(sfSyncResponse).isNotNull();

        verify(sfDocSyncService).syncDocUploadDataToSf(APPLICATION_ID, ApplicationState.DDE, customerId.toString());
        verify(caseHistoryService).saveCPCSentBackForSubmittedApplication(APPLICATION_ID);
    }

    @Test
    void shouldSyncDataToSfForCpcValidationStage() throws JsonProcessingException {
        when(sfPreDoCpcSyncService.sync(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, PRE_DO_CPC_VALIDATION);
        assertThat(sfSyncResponse).isNotNull();

        verify(sfPreDoCpcSyncService).sync(APPLICATION_ID);
        verify(caseHistoryService).saveCPCSentBackForSubmittedApplication(APPLICATION_ID);
    }

    @Test
    void shouldThrowInvalidRequestExceptionWhenSynchronousSfSyncIsCalledWithInvalidSfStage()
            throws JsonProcessingException {

        InvalidRequestException exception = assertThrows(
                InvalidRequestException.class, () -> sfService.getSynchronousSfSyncResponse(APPLICATION_ID, UPTO_QDE1));
        assertEquals(exception.getMessage(), INVALID_STAGE.getMessage());

        verify(sfBreOutputSyncService, never()).syncBreOutput(anyString());
        verify(repaymentRequestHandler, never()).syncJob(anyString());
        verify(conditionAndDeviationRequestHandler, never()).syncJob(anyString());
        verify(underwriterApprovalService, never()).send(anyString(), any());
        verify(caseHistoryService, never()).saveUWSentBackForSubmittedApplication(anyString());
        verify(sfDocSyncService, never()).syncDocUploadDataToSf(anyString(), any());
        verify(caseHistoryService, never()).saveCPCSentBackForSubmittedApplication(anyString());
    }

    @Test
    void shouldSyncWithdrawalData() throws JsonProcessingException {
        when(withdrawalRequestHandler.syncJob(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().build());
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, WITHDRAWAL);
        assertThat(sfSyncResponse).isNotNull();
    }

    @Test
    void shouldSyncLeadSourceDataToSfSuccessfully() throws JsonProcessingException {
        commonMockForUptoQde1StageSfSync();
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());

        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        LoanApplication loanApplication = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .getFirst()
                        .getBody(),
                LoanApplication.class);

        assertThat(loanApplication.getLeadSourceId()).isEqualTo("BUSINESS DIRECT");
        assertThat(loanApplication.getLeadSourceType()).isEqualTo("93");
    }

    private void mockForQdeWithoutSfClient() {
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetails()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        //        when(loanClient.fetchHunterDetails(APPLICATION_ID))
        //                .thenReturn(MfResponse.ok(
        //                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());
    }

    private void commonMockForUptoQde1StageSfSync() throws JsonProcessingException {
        mockForQdeWithoutSfClient();
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
    }

    @Test
    void shouldSyncDataToSfForDocUploadStageAndShouldNotCreateCaseHistoryIfApplicationStateIsNotDDE()
            throws JsonProcessingException {
        when(loanClient.getStatus(APPLICATION_ID))
                .thenReturn(Mono.just(MfResponse.ok(StatusResponse.builder()
                        .applicationStatus(ApplicationState.TA)
                        .build())));
        when(sfDocSyncService.syncDocUploadDataToSf(APPLICATION_ID, ApplicationState.TA))
                .thenReturn(SfSyncResponse.builder().build());

        SfSyncResponse sfSyncResponse = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, DOC_UPLOAD);
        assertThat(sfSyncResponse).isNotNull();

        verify(sfDocSyncService).syncDocUploadDataToSf(APPLICATION_ID, ApplicationState.TA);
        verify(caseHistoryService, never()).saveCPCSentBackForSubmittedApplication(APPLICATION_ID);
    }

    @Test
    void shouldDeactivatePreviousQdeIfAvailable() throws JsonProcessingException {
        mockForQdeWithoutSfClient();

        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildQdeInactivateResponse());

        String applicantFinancialId = "AF-00008539";
        ApplicantFinancialsObjectRequestBuilder applicantFinancialsObjectRequestBuilder =
                new ApplicantFinancialsObjectRequestBuilder();
        CompositeRequest applicantFinancialPatchRequest =
                applicantFinancialsObjectRequestBuilder.prepareInactivePatchCompositeRequest(
                        applicantFinancialId, "refApplicantFinancials");
        CompositeRequest applicantFinancialGetRequest =
                applicantFinancialsObjectRequestBuilder.prepareGetCompositeRequest(
                        "refGetApplicantFinancials", "refPatchApplicantFinancials");
        List<CompositeRequest> applicantFinancialRequests =
                Arrays.asList(applicantFinancialPatchRequest, applicantFinancialGetRequest);
        when(applicantFinancialsRequestHandler.buildCompositeRequestsForQdeOneSync(any()))
                .thenReturn(applicantFinancialRequests);
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(Boolean.TRUE.toString(), sfSyncResponse.getIsSuccessful());
        verify(applicantFinancialsRequestHandler).saveQdeOneSyncInactiveDetails(strIterCaptor.capture());
        assertEquals(applicantFinancialId, strIterCaptor.getValue().getFirst());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForSameCurrentAndPermanentAddress_Guarantor() throws JsonProcessingException {
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        when(loanClient.fetchActiveLoanDetails(any()))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));

        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponseCustomers(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(buildDocDmsIdMappingListResponse())
                .build();
        loanDetailsResponse.getCustomerDetails().getFirst().getKycDetails().setForm60Available(true);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(any())).thenReturn(MfResponse.ok(buildKycDetailsWithPan()));
        when(customerClient.fetchCustomerDetails(any(), any()))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponseForSameCurrentAndPermanentAddress(any(), any())));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_2"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(customerClient.fetchAmlResponse(UUID.fromString("7cc29190-14af-4b4b-b337-8569c98504e4")))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(customerClient.fetchAmlResponse(UUID.fromString("7cc29190-14af-4b4b-b337-8569c98504e7")))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
    }

    @Test
    void shouldSyncPayoutDataToSfSuccessfullyV2() throws JsonProcessingException {
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        when(offerClient.getOffers(APPLICATION_ID, true))
                .thenReturn(MfResponse.ok(OfferResponse.builder()
                        .offerList(
                                List.of(OfferDetails.builder().offerId(OFFER_ID).build()))
                        .build()));
        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());
        when(offerClient.getInsuranceDetails(OFFER_ID)).thenReturn(mfResponse);
        when(sfClient.postToSf(any())).thenReturn(buildThreeDocumentsOnSF(getReferenceIds(), SUCCESS_BODY_LIST));
        when(applicantMappingRepository.findByApplicationMappingApplicationId(any()))
                .thenReturn(Optional.of(applicantMapping));

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, ADD_ON_PRODUCTS);

        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(offerClient).getInsuranceDetails(any());
        verify(sfClient).postToSf(any());
        assertNotNull(sfSyncResponse);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForIncomeValidation() throws JsonProcessingException {
        when(applicantFinancialsRequestHandler.syncJob(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, INCOME_VALIDATION);
        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForLoanSanctionDate() throws JsonProcessingException {
        when(loanSanctionDateRequestHandler.syncJob(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, LOAN_SANCTION_DATE);
        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
    }

    @Test
    void shouldSyncDataToSfSuccessfullyWhenKycVerificationDetailsIsNull() throws JsonProcessingException {
        DocReferenceIdMapping docReferenceIdMapping = DocReferenceIdMapping.builder()
                .docReferenceId("DOC_REF_1")
                .sfDocReferenceId("Physical consent-Upload")
                .build();
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .build();
        DocResponse docResponse = DocResponse.builder()
                .activeDocuments(List.of(buildDocDmsIdMappingResponse(docId, customerId)))
                .build();
        when(loanClient.fetchActiveLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildLoanInfoResponse(leadId, APPLICATION_ID, userId)));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(leadClient.fetchLeadDetails(leadId)).thenReturn(MfResponse.ok(buildLeadDetails()));
        when(kycClient.fetchKycDetails(customerId)).thenReturn(MfResponse.ok(buildKycDetails()));
        when(kycClient.fetchKycVerificationDetails(APPLICATION_ID, String.valueOf(customerId)))
                .thenReturn(MfResponse.ok(kycVerificationDetailsResponse()));
        when(customerClient.fetchCustomerDetails(customerId, additionalParamsWithNameAndAddressStrength))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(consentClient.getConsentDetails(leadId, mobileNumber))
                .thenReturn(MfResponse.ok(buildLinkConsentResponse(ENGLISH, "LINK")));
        when(userServiceClient.fetchUserDetails(userId))
                .thenReturn(MfResponse.ok(UserData.builder()
                        .user(UserDetails.builder().name(userName).build())
                        .build()));
        when(documentClient.fetchDmsDocIdMapping(leadId)).thenReturn(MfResponse.ok(docResponse));
        when(docReferenceIdMappingRepository.findByDocReferenceId("DOC_REF_1"))
                .thenReturn(Optional.ofNullable(docReferenceIdMapping));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
        when(customerClient.fetchAmlResponse(customerId))
                .thenReturn(MfResponse.ok(AmlResponse.builder().match(true).build()));
        when(loanClient.fetchHunterDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(
                        HunterResponse.builder().score(900L).decision("ACCEPT").build()));
        when(masterDataClient.getAddOnProducts()).thenReturn(MfResponse.ok(buildAddOnProductResponse()));
        when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(any(), any()))
                .thenReturn(Optional.of(applicantMapping));
        when(customerClient.fetchDedupeAndExposure(any()))
                .thenReturn(DedupeAndExposureResponse.builder().build());
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UPTO_QDE1);
        assertEquals(TRUE, sfSyncResponse.getIsSuccessful());
        verify(loanClient).fetchActiveLoanDetails(any());
        verify(loanClient).fetchLoanDetails(any());
        verify(kycClient).fetchKycDetails(any());
        verify(customerClient).fetchCustomerDetails(any(), any());
        verify(userServiceClient).fetchUserDetails(any());
        verify(sfClient).postToSf(graphRequestArgumentCaptor.capture());
        Applicant applicant = objectMapper.convertValue(
                graphRequestArgumentCaptor
                        .getValue()
                        .getGraphs()
                        .getFirst()
                        .getCompositeRequest()
                        .get(1)
                        .getBody(),
                Applicant.class);
        assertFalse(applicant.getPanIdDV());
        assertFalse(applicant.getFirstNameDV());
        assertFalse(applicant.getPoiIdDV());
        assertFalse(applicant.getPoaIdDv());
        assertNull(applicant.getVirtualId());
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndStage() throws JsonProcessingException {
        SfSyncStage stage = UW_APPROVAL;
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        when(sfBreOutputSyncService.syncBreOutput(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        when(applicantMappingRepository.findByApplicationMappingApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicantMapping));

        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));

        when(repaymentRequestHandler.syncJob(any()))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        when(sfClient.postToSf(any(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());

        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());

        when(loanClient.getStatus(APPLICATION_ID)).thenReturn(Mono.just(statusResponseMfResponse));

        when(offerClient.getInsuranceDetails(OFFER_ID)).thenReturn(mfResponse);

        doNothing().when(caseHistoryService).saveUWSentBackForSubmittedApplication(APPLICATION_ID);

        SfSyncResponse response = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, stage);

        assertNull(response);
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndUW_APPROVAL_DEFERRAL_NO_DEVIATION()
            throws JsonProcessingException {
        SfSyncStage stage = UW_APPROVAL_DEFERRAL_NO_DEVIATION;
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        when(sfBreOutputSyncService.syncBreOutput(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        when(applicantMappingRepository.findByApplicationMappingApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicantMapping));

        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));

        when(repaymentRequestHandler.syncJob(any()))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        when(sfClient.postToSf(any(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());

        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());

        when(loanClient.getStatus(APPLICATION_ID)).thenReturn(Mono.just(statusResponseMfResponse));

        when(offerClient.getInsuranceDetails(OFFER_ID)).thenReturn(mfResponse);

        doNothing().when(caseHistoryService).saveUWSentBackForSubmittedApplication(APPLICATION_ID);

        SfSyncResponse response = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, stage);

        assertNull(response);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForCPV_UW() throws JsonProcessingException {

        getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndUW_APPROVAL_DEFERRAL_NO_DEVIATION();

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, UW_APPROVAL);

        assertNull(sfSyncResponse);
    }

    @Test
    void syncDataToSfForCPV() throws JsonProcessingException {
        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, CPV, customerId.toString());
        assertNull(sfSyncResponse);
    }

    @Test
    void syncDataToSfForINVALID() throws JsonProcessingException {
        assertThrows(
                InvalidRequestException.class,
                () -> sfService.syncDataToSf(APPLICATION_ID, SANCTION, customerId.toString()));
    }

   

        @Test
        void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndUW_APPROVAL()
                throws JsonProcessingException {
            SfSyncStage stage = UW_APPROVAL;
            ApplicantMapping applicantMapping = ApplicantMapping.builder()
                    .applicantId(UUID.fromString(applicantId))
                    .sfApplicantId("APPID-00000602")
                    .build();
           GraphResponseDetail graphResponseDetail = new GraphResponseDetail();
    
            graphResponseDetail.setGraphs(List.of(new Graph()));
    
            LoanDetailsResponse loanDetailsResponse =
                    buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
    
            when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
    
            when(applicantMappingRepository.findByApplicationMappingApplicationIdAndApplicantId(APPLICATION_ID,
     customerId))
                    .thenReturn(Optional.of(applicantMapping));
    
            when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));
    
            when(repaymentRequestHandler.syncJob(any()))
                    .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());
    
            when(sfClient.postToSf(any(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());
    
            MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());
    
            MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                    .applicationStatus(ApplicationState.CREATED)
                    .build());
    
           when(loanClient.getStatus(APPLICATION_ID)).thenReturn(Mono.just(statusResponseMfResponse));
    
            when(offerClient.getInsuranceDetails(OFFER_ID)).thenReturn(mfResponse);
    
            doNothing().when(caseHistoryService).saveUWSentBackForSubmittedApplication(APPLICATION_ID);
    
            SfSyncResponse response = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, stage);
    
           assertNull(response);
        }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndUW_APPROVAL_With_Customer()
            throws JsonProcessingException {
        SfSyncStage stage = UW_APPROVAL;
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());
        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());
        assertEquals(1000, mfResponse.getData().mls().premium());
    }

    @Test
    void shouldSyncPreDoCpcValidationSuccessfully() throws JsonProcessingException {
        String applicationId = "applicationId";
        String customerId = "customerId";
        SfSyncResponse expectedResponse = new SfSyncResponse();

        when(sfPreDoCpcSyncService.sync(applicationId, customerId)).thenReturn(expectedResponse);

        SfSyncResponse actualResponse =
                sfService.getSynchronousSfSyncResponse(applicationId, PRE_DO_CPC_VALIDATION, customerId);

        assertEquals(expectedResponse, actualResponse);
        verify(sentBackService).updateStatusAsCompletedForSubmittedApplicationForTvrAndPreDo(applicationId);
        verify(caseHistoryService).saveCPCSentBackForSubmittedApplication(applicationId);
    }

    @Test
    void shouldSyncPreDoDocUploadSuccessfully() throws JsonProcessingException {
        String applicationId = "applicationId";
        String customerId = "customerId";
        SfSyncResponse expectedResponse = new SfSyncResponse();

        when(sfPreDoDocSyncService.sync(applicationId, customerId)).thenReturn(expectedResponse);

        SfSyncResponse actualResponse =
                sfService.getSynchronousSfSyncResponse(applicationId, PRE_DO_DOC_UPLOAD, customerId);

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void shouldSyncLoanSanctionDateSuccessfully() throws JsonProcessingException {
        String applicationId = "applicationId";
        SfSyncResponse expectedResponse = new SfSyncResponse();

        when(loanSanctionDateRequestHandler.syncJob(applicationId)).thenReturn(expectedResponse);

        SfSyncResponse actualResponse = sfService.getSynchronousSfSyncResponse(applicationId, LOAN_SANCTION_DATE, null);

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void shouldSyncRepaymentScheduleSuccessfully() throws JsonProcessingException {
        String applicationId = "6a82a23f-4b1f-11ef-a6fc-496a324590c0";
        SfSyncResponse expectedResponse = new SfSyncResponse();

        when(repaymentRequestHandler.syncJob(applicationId)).thenReturn(expectedResponse);

        SfSyncResponse actualResponse = sfService.getSynchronousSfSyncResponse(applicationId, REPAYMENT_SCHEDULE, null);

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndSANCTION() throws JsonProcessingException {
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());

        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());

        SfSyncResponse response = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, PRE_DO_DOC_UPLOAD);

        assertNull(response);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForCPV_SANCTION() throws JsonProcessingException {

        getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndUW_APPROVAL_DEFERRAL_NO_DEVIATION();

        SfSyncResponse sfSyncResponse = sfService.syncDataToSf(APPLICATION_ID, SANCTION);

        assertNull(sfSyncResponse);
    }

    @Test
    void shouldSyncDataToSfSuccessfullyForCPV_INVALID() throws JsonProcessingException {

        getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndUW_APPROVAL_DEFERRAL_NO_DEVIATION();

        assertThrows(InvalidRequestException.class, () -> sfService.syncDataToSf(APPLICATION_ID, PRE_DO_DOC_UPLOAD));
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndLOAN_SANCTION_DATE()
            throws JsonProcessingException {
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());

        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());

        SfSyncResponse response = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, LOAN_SANCTION_DATE);

        assertNull(response);
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndREPAYMENT_SCHEDULE()
            throws JsonProcessingException {
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());

        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());

        SfSyncResponse response = sfService.getSynchronousSfSyncResponse(APPLICATION_ID, REPAYMENT_SCHEDULE);

        assertNull(response);
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndStageUW_APPROVAL()
            throws JsonProcessingException {
        SfSyncStage stage = UW_APPROVAL;
        ApplicantMapping applicantMapping = ApplicantMapping.builder()
                .applicantId(UUID.fromString(applicantId))
                .sfApplicantId("APPID-00000602")
                .build();
        GraphResponseDetail graphResponseDetail = new GraphResponseDetail();

        graphResponseDetail.setGraphs(List.of(new Graph()));

        when(sfBreOutputSyncService.syncBreOutput(APPLICATION_ID))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        when(applicantMappingRepository.findByApplicationMappingApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicantMapping));

        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));

        when(repaymentRequestHandler.syncJob(any()))
                .thenReturn(SfSyncResponse.builder().isSuccessful(TRUE).build());

        when(sfClient.postToSf(any(GraphRequest.class))).thenReturn(buildSuccessGraphResponseDetail());

        MfResponse<InsuranceResponse> mfResponse = MfResponse.ok(buildInsuranceResponse());

        MfResponse<StatusResponse> statusResponseMfResponse = MfResponse.ok(StatusResponse.builder()
                .applicationStatus(ApplicationState.CREATED)
                .build());

        when(loanClient.getStatus(APPLICATION_ID)).thenReturn(Mono.just(statusResponseMfResponse));

        when(offerClient.getInsuranceDetails(OFFER_ID)).thenReturn(mfResponse);

        doNothing().when(caseHistoryService).saveUWSentBackForSubmittedApplication(APPLICATION_ID);

        SfSyncResponse response =
                sfService.getSynchronousSfSyncResponse(APPLICATION_ID, UW_APPROVAL, customerId.toString());

        assertNull(response);
    }

    @Test
    void getSynchronousSfSyncResponseReturnsSuccessForValidApplicationIdAndStageInvalid()
            throws JsonProcessingException {
        assertThrows(
                InvalidRequestException.class,
                () -> sfService.getSynchronousSfSyncResponse(APPLICATION_ID, SANCTION, customerId.toString()));
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfApplicationNotFoundInDb2() {
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID)).thenReturn(Optional.empty());
        InvalidRequestException exception =
                assertThrows(InvalidRequestException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        assertEquals(SF_APPLICATION_MAPPING_NOT_FOUND.getMessage(), exception.getMessage());

        verify(loanClient, times(0)).fetchPostSanctionLoanDetails(any());
        verify(loanClient, times(0)).fetchLoanDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchLoanDetailsIsFailed2() {
        when(loanClient.fetchLoanDetails(APPLICATION_ID))
                .thenThrow(new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE));
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient, times(0)).fetchPostSanctionLoanDetails(any());
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchPostSanctionLoanDetailsIsFailed2() {
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenThrow(new ExternalServiceResponseException(
                        LOAN_SERVICE_FETCH_POST_SANCTION_LOAN_DETAILS_INVALID_RESPONSE));
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        assertEquals(
                LOAN_SERVICE_FETCH_POST_SANCTION_LOAN_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient, times(0)).fetchCustomerDetails(any(), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchCustomerDetailsIsFailed2() {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        when(customerClient.fetchCustomerDetails(customerId, Set.of("ucicIdResponse")))
                .thenThrow(
                        new ExternalServiceResponseException(CUSTOMER_SERVICE_FETCH_CUSTOMER_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        assertEquals(CUSTOMER_SERVICE_FETCH_CUSTOMER_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient, times(0)).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchDisbursementBankDetailsIsFailed2() {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenThrow(new ExternalServiceResponseException(MASTER_SERVICE_FETCH_BANK_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        assertEquals(MASTER_SERVICE_FETCH_BANK_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient, times(0)).fetchLoanChargeDetails(any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataToSfIfFetchLoanChargeDetailsIsFailed2() {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenReturn(MfResponse.ok(buildDisbursementBankDetailResponse()));
        when(loanClient.fetchLoanChargeDetails(any(), any()))
                .thenThrow(
                        new ExternalServiceResponseException(LOAN_SERVICE_FETCH_LOAN_CHARGE_DETAILS_INVALID_RESPONSE));

        ExternalServiceResponseException exception = assertThrows(
                ExternalServiceResponseException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        assertEquals(LOAN_SERVICE_FETCH_LOAN_CHARGE_DETAILS_INVALID_RESPONSE.getMessage(), exception.getMessage());
        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient).fetchLoanChargeDetails(any(), any());
        verify(payoutRequestHandler, never()).addUpdatePayoutDetailsRequest(any(), any(), any());
        verify(sfClient, times(0)).postToSf(any());
    }

    @Test
    void shouldNotSyncPostSanctionDataIfSfSyncApiGivesErrorResponse2() throws JsonProcessingException {
        ApplicationMapping applicationMapping = SfSyncTestData.getApplicationMapping(APPLICATION_ID);
        when(applicationMappingRepository.findByApplicationId(APPLICATION_ID))
                .thenReturn(Optional.of(applicationMapping));
        when(customerClient.fetchCustomerDetails(customerId, additionalParams))
                .thenReturn(MfResponse.ok(buildCustomerDetailResponse(mobileNumber, customerId.toString(), null)));
        when(loanClient.fetchPostSanctionLoanDetails(APPLICATION_ID))
                .thenReturn(MfResponse.ok(buildPostSanctionLoanResponse()));
        LoanDetailsResponse loanDetailsResponse =
                buildLoanDetailsResponse(customerId, CustomerType.PRIMARY, APPLICATION_ID);
        when(loanClient.fetchLoanDetails(APPLICATION_ID)).thenReturn(MfResponse.ok(loanDetailsResponse));
        when(masterDataClient.fetchDisbursementBankDetail(ifscCodeUuid))
                .thenReturn(MfResponse.ok(buildDisbursementBankDetailResponse()));
        when(loanClient.fetchLoanChargeDetails(any(), any()))
                .thenReturn(MfResponse.ok(buildLoanChargeResponse(APPLICATION_ID)));
        when(loanClient.fetchAccountVerificationDetails(APPLICATION_ID, customerId.toString()))
                .thenReturn(MfResponse.ok(buildAccountVerificationDetailsResponse(APPLICATION_ID)));
        when(offerClient.getOffers(APPLICATION_ID, Boolean.TRUE)).thenReturn(MfResponse.ok(buildOfferResponse()));
        when(sfClient.postToSf(isA(GraphRequest.class))).thenReturn(buildErrorGraphResponseDetail());
        assertThrows(SfSyncException.class, () -> sfService.syncPostSanctionDataToSf(APPLICATION_ID));

        verify(loanClient).fetchLoanDetails(APPLICATION_ID);
        verify(loanClient).fetchPostSanctionLoanDetails(APPLICATION_ID);
        verify(customerClient).fetchCustomerDetails(eq(customerId), any());
        verify(masterDataClient).fetchDisbursementBankDetail(any());
        verify(loanClient).fetchLoanChargeDetails(any(), any());
        verify(offerClient).getOffers(APPLICATION_ID, true);
        verify(payoutRequestHandler)
                .addUpdatePayoutDetailsRequest(eq(APPLICATION_ID), eq(loanDetailsResponse), anyList());
        verify(sfClient).postToSf(any());
    }
}

